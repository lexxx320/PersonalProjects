\documentclass[12pt]{article}

\usepackage[margin=1 in]{geometry}

\frenchspacing

\begin{document}

\centerline{\bf Research Proposal -- Matthew Le} 

Clock speeds in microprocessors are no longer increasing at the rate that they did years ago due to power consumption constraints and heat dissipation. In order to increase the speed of computation, multicore computing must be exploited. The problem with wide-scale deployment of multicore computing is that the development of multithreaded programs is very difficult and error prone due to race conditions, which can lead to subtle bugs that are both hard to detect and difficult to reproduce.

Software transactional memory (STM) is a promising solution to the difficulty of concurrent programming, where programmers are allowed to wrap sections of code in atomic blocks called transactions. The runtime system then guarantees that the transaction gets executed atomically with respect to other concurrently running transactions.  STM has been shown to provide competitive performance on certain applications, meanwhile substantially easing the intellectual burden placed on the programmer.

Unfortunately, there remain a number of significant challenges.  One large open problem in the area of STM is the issue of fairness.  Traditionally, an STM implementation records the locations of memory that were accessed and modified within a transaction and checks at the end to see if any other threads interfered with its execution.  If so, it aborts the transaction and re-executes from the beginning.  If no violations were detected, then the transaction is committed and other threads are able to observe the effects of the transaction.  The problem with fairness arises when threads attempt to execute long running transactions and other threads execute short lived transactions that modify the same memory locations.  Since the short lived transactions get the opportunity to commit first, they can cause the long running transaction to repeatedly abort.

My research is currently focused on addressing this issue in the context of a functional programming language.  I am interested in implementing software transactional memory that can avoid redundant work that has not been affected by a transaction violation.  This can be done by \emph{checkpointing} a transaction, such that when validating, we restore execution to the latest checkpoint that has not been compromised by another thread.  In many other languages, checkpointing is very expensive, making it infeasible to do transparently.  This pushes a burden onto the programmer, where they must either split their transactions into smaller pieces, which can compromise the correctness of the algorithm, or they are required to annotate the program with checkpoints, which can be difficult to reason about and ineffective.  

In the context of a functional language, we can exploit compilation techniques that make checkpointing extremely cheap.  When compiling functional programs, it is common to implement a continuation passing style (CPS) transformation, making the program more amenable to later optimizations.  Essentially, the CPS transformation rewrites the program such that functions never return.  Instead, each function takes an additional parameter called the return continuation that represents ``the rest'' of the program.  When a function completes, instead of returning to some previous context, it passes its result off to the return continuation, which evaluates the remainder of the program.

After having CPS converted a program, it becomes possible to capture various control flow operations that would otherwise be difficult and inefficient to implement.  One example of this is restoring a previous point in a program's execution.  Given that every function in a CPS converted program contains a return continuation representing the remainder of the program, it is possible to store this continuation in memory, and invoke it at a later point in the execution.  When invoked, the program's execution state will be exactly as it was when the continuation was captured.  This sort of restoration is only possible in an imperative language such as C or Java if the entire stack is copied at the point where control is to be restored.  To return to that point in the program, one would then need to overwrite the current stack with the one that was saved.  This has both linear time and space complexity, whereas capturing a continuation in a functional language that has been CPS converted takes only constant time and space complexity.

I believe that we can take advantage of this technique to create a more efficient and fair implementation of STM.  My proposal is to capture a continuation each time a memory location is initially read from in a transaction and store it in the transactional log.  When committing a transaction, as long as we validate logged operations in the order in which they happened, when a violation is detected, we can simply use the continuation stored in the log to restore execution to the exact point in which the violation occurred, avoiding any redundant work.  By avoiding redundant work when aborting a transaction, long running transactions can reach their commit point faster, increasing their likelihood of committing, which in practice I believe will lead to a fairer and more efficient implementation.

For the past year, I have been collaborating with researchers from RIT and the University of Chicago on the Manticore project, which extends Standard ML, a popular functional language, with parallel and concurrent features.  I plan on further extending the Manticore compiler and runtime system with my proposed STM implementation.  Manticore currently utilizes a CPS transformation that is used heavily by the runtime system and scheduling infrastructure.  I plan on capitalizing on this and related compiler/runtime system components in the implementation of my proposal.  

In addition to the implementation, I am also interested in proving the correctness of my solution.  There has been increasing interest in the formal semantics of STM, since implementations can become complicated quickly and contain subtle and unusual behavior if not considered carefully.  Similar STM implementations that perform full aborts have been given a formal operational semantics and have been proven to be linearizable, meaning committed transactions do not modify overlapping memory locations during their lifetimes.  I plan on proving linearizability for my proposed implementation by proving that it yields equivalent results to an STM implementation that performs full aborts.  I believe that this theorem will follow naturally from the fact that all reads that come before the point an aborted transaction is rolled back to are checked for consistency.  I have used this proof technique of relating increasingly more complex implementations to simpler ones that have proven to have certain properties in the past.  I believe that this is a theme that can be further exploited to tackle yet more sophisticated implementations in the future as well.  

Improving the state of the art in software transactional memory will have broader impacts in a number of areas.  Software transactional memory has not yet made its way into mainstream languages primarily for its insufficient performance and unfair throughput.  By being able to improve the performance and fairness of STM may make this a more practical alternative to lower level locking approaches to concurrent programming. Having an easy to use set of tools for developing concurrent programs will allow other researchers to quickly and productively implement high performance applications necessary to carry out their research.  Locally, I hope to include either a master's or undergraduate student on this project in an effort to increase exposure to the exciting world of programming language research.  












































\end{document}