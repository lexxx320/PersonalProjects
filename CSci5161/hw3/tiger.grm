structure A = Absyn

type pos = int
%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE | UMINUS | LOWPREC | LVALUEPREC

(*The nonterminals for the tiger language*)
%nonterm  exp of A.exp | program of A.exp | lvalue of A.var | dec of A.dec  
          | decs of A.dec list | exps of (A.exp * pos) list 
          | tydecList of A.dec 
          | tydecs of {name:Symbol.symbol, ty:A.ty, pos:pos} list
          | tydec of {name:Symbol.symbol, ty:A.ty, pos:pos}
          | vardec of A.dec 
          | fundec of A.fundec
          | fundecs of A.fundec list
          | fundecList of A.dec 
          | ty of A.ty 
          | tyfields of A.field list 
          | idEQExpPairs of (Symbol.symbol * A.exp * pos) list
          | optionalLValue of A.var -> A.var
          | tyfield of A.field
          | optionalFields of A.field list
          | idEQExpPair of Symbol.symbol * A.exp * pos
          | optionalIdEQExpPairs of (Symbol.symbol * A.exp * pos) list
          | expsRest of (A.exp * pos) list
          | commaExps of A.exp list
          | optionalCommaExps of A.exp list
          | optionalExps of A.exp

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger
%verbose

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%change EQ -> ASSIGN | ASSIGN -> EQ 

%prefer THEN ELSE LPAREN IF

%nonassoc LOWPREC
%nonassoc FUNCTION TYPE
%right SEMICOLON
%nonassoc ASSIGN
%nonassoc WHILE DO OF IF THEN 
%nonassoc ELSE
%left AND OR
%nonassoc EQ LT LE GT GE NEQ 
%left PLUS MINUS
%left TIMES DIVIDE
%nonassoc LPAREN RPAREN
%left UMINUS

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

(*Rules are labeled by number to make it easier to identify what rules
  are involved in shift/reduce and reduce/reduce conflicts*)
program	: exp				(exp)     (*0*)


(*Use inherited attributes to put together lvalues*)
lvalue : ID optionalLValue (optionalLValue(A.SimpleVar(Symbol.symbol(ID), 
                              IDleft)))

optionalLValue : DOT ID optionalLValue (fn x => optionalLValue(A.FieldVar(
                  x, Symbol.symbol(ID), IDleft)))
                |LBRACK exp RBRACK optionalLValue (fn x => optionalLValue(
                    A.SubscriptVar(x, exp, LBRACKleft)))
                |(fn x => x)

        
exp: NIL		(A.NilExp)                                              (*5*)
    |INT  (A.IntExp(INT))                                         (*6*)
    |STRING (A.StringExp(STRING, STRINGleft))                     (*7*)
    |lvalue (A.VarExp(lvalue))                                    (*8*)
    |LPAREN exps RPAREN (A.SeqExp(exps))                          (*9*)
    |ID LPAREN optionalCommaExps RPAREN (A.CallExp({func = Symbol.symbol(ID), 
        args = optionalCommaExps, pos = IDleft}))           (*10*)
    |LPAREN exp RPAREN (exp)                                      (*11*)
    |exp PLUS exp (A.OpExp({left = exp1, oper = A.PlusOp,           (*12*)
        right = exp2, pos = PLUSleft}))                             
    |exp MINUS exp (A.OpExp({left = exp1, oper = A.MinusOp,         (*13*)
        right = exp2, pos = MINUSleft}))
    |exp TIMES exp (A.OpExp({left = exp1, oper = A.TimesOp,         (*14*)
        right = exp2, pos = TIMESleft}))
    |exp DIVIDE exp (A.OpExp({left = exp1, oper = A.DivideOp,       (*15*)
        right = exp2, pos = DIVIDEleft}))
    |exp EQ exp (A.OpExp({left = exp1, oper = A.EqOp,               (*16*)
        right = exp2, pos = EQleft}))
    |exp NEQ exp (A.OpExp({left = exp1, oper = A.NeqOp,             (*17*)
        right = exp2, pos = NEQleft}))
    |exp LT exp (A.OpExp({left = exp1, oper = A.LtOp,               (*18*)
        right = exp2, pos = LTleft}))
    |exp LE exp (A.OpExp({left = exp1, oper = A.LeOp,               (*19*)
        right = exp2, pos = LEleft}))
    |exp GT exp (A.OpExp({left = exp1, oper = A.GtOp,               (*20*)
        right = exp2, pos = GTleft}))
    |exp GE exp (A.OpExp({left = exp1, oper = A.GeOp,               (*21*)
        right = exp2, pos = GEleft}))
    |exp AND exp (A.IfExp({test = exp1, then' = exp2,               (*22*)
        else' = SOME (A.IntExp(0)), pos = exp1left}))
    |exp OR exp (A.IfExp({test = exp1, then' = A.IntExp(1),         (*23*)
        else' = SOME exp2, pos = exp1left}))
    |LET decs IN optionalExps END (A.LetExp({decs = decs, body = optionalExps,
        pos = LETleft}))                                            (*24*)
    |MINUS exp %prec UMINUS (A.OpExp({left = A.IntExp(0), oper = A.MinusOp, (*25*)
          right = exp, pos = MINUSleft}))
    |lvalue ASSIGN exp (A.AssignExp({var = lvalue, exp = exp,  (*26*)
          pos = lvalueleft}))
    |WHILE exp DO exp (A.WhileExp({test = exp1, body = exp2, pos = WHILEleft}))
    |FOR ID ASSIGN exp TO exp DO exp (A.ForExp({var = Symbol.symbol(ID), (*26*)
        escape = ref true, lo = exp1, hi = exp2, body = exp3, pos = FORleft}))
    |BREAK (A.BreakExp(BREAKleft))                                  (*27*)
    |ID LBRACK exp RBRACK OF exp (A.ArrayExp({typ = Symbol.symbol(ID),  (*28*)
        size = exp1, init = exp2, pos = IDleft}))
    |ID LBRACE optionalIdEQExpPairs RBRACE (A.RecordExp({fields =       (*29*)
        optionalIdEQExpPairs, typ = Symbol.symbol(ID), pos = IDleft}))
    |IF exp THEN exp (A.IfExp({test = exp1, then' = exp2, else' = NONE, (*30*)
        pos = IFleft}))
    |IF exp THEN exp ELSE exp (A.IfExp({test = exp1, then' = exp2,    (*31*)
        else' = SOME exp3, pos = IFleft}))
    |LPAREN RPAREN (A.SeqExp([]))

optionalExps : exps (A.SeqExp(exps))                   (*32*)
             | exp (exp)

optionalIdEQExpPairs : idEQExpPairs (idEQExpPairs)   (*34*)
                      |             ([])             (*35*)

idEQExpPairs : idEQExpPair COMMA idEQExpPairs               (*36*)
                            (idEQExpPair :: idEQExpPairs)
              |idEQExpPair ([idEQExpPair])                  (*37*)

idEQExpPair : ID EQ exp ((Symbol.symbol(ID), exp, IDleft))  (*38*)

exps :  exp SEMICOLON expsRest ((exp, expleft)::expsRest)   (*39*)

expsRest : exp ([(exp, expleft)])                           (*40*)
          |exp SEMICOLON expsRest ((exp, expleft) :: expsRest)  (*41*)

optionalCommaExps : commaExps (commaExps)                     (*42*)
                   | ([])                                     (*43*)

commaExps : exp COMMA commaExps (exp :: commaExps)            (*44*)
           |exp ([exp])                                       (*45*)

decs : dec decs (dec::decs)                                   (*46*)
      | ([])                                                  (*47*)

dec : tydecList (tydecList)                                           (*48*)
     |vardec (vardec)                                         (*49*)
     |fundecList (fundecList)                                         (*50*)

tydecList: tydecs (A.TypeDec(tydecs))

(*We assign LOWPREC precedence to this production in order to avoid a shift
reduce conflict with the TYPE keyword.  This works because it causes 
the parser to always shift the TYPE terminal, since it has higher
precedence. *)
tydecs : tydec tydecs %prec LOWPREC (tydec :: tydecs)
        |tydec        %prec LOWPREC ([tydec])

tydec : TYPE ID EQ ty ({name = Symbol.symbol(ID),  (*51*)
          ty = ty, pos = IDleft})                   

ty : ID (A.NameTy(Symbol.symbol(ID), IDleft))                   (*52*)
    |LBRACE optionalFields RBRACE (A.RecordTy(optionalFields))  (*53*)
    |ARRAY OF ID (A.ArrayTy(Symbol.symbol(ID), ARRAYleft))      (*54*)

(*To deal with possibly no comma seperated fields*)
optionalFields : tyfields (tyfields)                              (*55*)
                |         ([])                                    (*56*)

tyfields : tyfield COMMA tyfields (tyfield :: tyfields)           (*57*)
          |tyfield                ([tyfield])                     (*58*)
          
tyfield: ID COLON ID  ({name = Symbol.symbol(ID1), escape = ref true, (*59*)
                             typ = Symbol.symbol(ID2), pos = IDleft})

vardec : VAR ID ASSIGN exp (A.VarDec({name = Symbol.symbol(ID),     (*60*)
          escape = ref true, typ = NONE, init = exp, pos = VARleft}))
        |VAR ID COLON ID ASSIGN exp (A.VarDec({name = Symbol.symbol(ID), (*61*)
          escape = ref true, typ = SOME (Symbol.symbol(ID2), IDleft), 
          init = exp, pos = VARleft}))

fundecList : fundecs (A.FunctionDec(fundecs))                 (*62*)

(*We assign LOWPREC precedence to this production in order to avoid a shift
reduce conflict with the FUNCTION keyword.  This works because it causes 
the parser to always shift the FUNCTION terminal, since it has higher
precedence. *)
fundecs : fundec fundecs %prec LOWPREC (fundec :: fundecs)           (*63*)
         |  fundec  %prec LOWPREC ([fundec])                         (*64*)

fundec : FUNCTION ID LPAREN optionalFields RPAREN EQ exp ({  (*65*)
          name = Symbol.symbol(ID), params = optionalFields, result = NONE, 
          body = exp, pos = FUNCTIONleft})
        |FUNCTION ID LPAREN optionalFields RPAREN COLON ID EQ exp  (*66*)
          ({name = Symbol.symbol(ID1), params = optionalFields, 
          result = SOME (Symbol.symbol(ID2), ID2left), body = exp, 
          pos = FUNCTIONleft})





        
      

