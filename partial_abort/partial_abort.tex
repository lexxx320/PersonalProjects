\documentclass[9pt]{article}

\usepackage[margin=.9in]{geometry}

\usepackage{amsmath}
\usepackage{url}
\usepackage{graphicx}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{verbatim}
\usepackage[inference]{semantic}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{color}
\usepackage{amsthm}

\RequirePackage{latexsym,amsmath,amssymb,proof,amsthm,color,
  ifthen,times,enumerate,proof,longtable}

\newcommand{\aeval}[1]{\mathcal{A}[#1]}
\newcommand{\actxt}[0]{\mathcal{A}}
\newcommand{\eval}[1]{\mathcal{E}[#1]}
\newcommand{\ctxt}[0]{\mathcal{E}}
\newcommand{\loc}[0]{\ell}
\newcommand{\atomic}[1]{\text{atomic}(#1)}
\newcommand{\alloc}[1]{\text{ref} \; #1}
\newcommand{\commit}[0]{\text{commit}}
\newcommand{\abort}[0]{\text{abort}}
\newcommand{\fork}[1]{\text{fork } #1}
\newcommand{\bump}[1]{\text{bump } #1}
\begin{document}
\begingroup\makeatletter\def\f@size{10}\check@mathfonts


\begin{displaymath}
\begin{array}{rcll}
\text{Variables } \;\;\; x &\in& Var \\
\text{Counter} \;\;\; C &\in& \mathbb{N} \\
\text{Values } \;\;\; v &::=& \lambda x. e \; | \; \loc \; | \; () \\
\text{Expressions } \;\;\; e &::=& v \; | \; x \; | \; e \; e \; | \; !e \; | \; e := e \; | \; \alloc{e} \; | \; \fork{e} \; | \; \atomic{e}\\
\text{Non-Transactional Context } \;\;\; \ctxt &::=& [\cdot] \; | \; \ctxt \; e \; | \; v \; \ctxt \; | \; ! \ctxt \; | \; \ctxt := e \; | \; v := \ctxt \; | \; \alloc{\ctxt} \\
\text{Transactional Context } \;\;\; \actxt &::=& [\cdot] \; | \; \actxt \; e \; | \; v \; \actxt \; | \; ! \actxt \; | \; \actxt := e \; | \; v := \actxt \; | \; \alloc{\actxt} \; | \; \atomic{\actxt} \\
\text{Heap } \;\;\; H &::=& \cdot \; | \; H, \loc \mapsto (v, C) \\
\text{Thread Pool} \;\;\; T &::=& \cdot \; | \; \Theta[L; e] \; | \; T \cup T \\
\text{Transactional Log } \;\;\; L &::=& \cdot \; | \; L, \loc \mapsto (v, C, \actxt)_{op}  \\
\text{Operations } \;\;\; op &::=& R \; | \; W \\
\end{array}
\end{displaymath}

$\boxed{C; H; T \rightarrow C; H' ;T'}$
\[%Parallel composition and non-transactional eval ctxt
\infer[]{C; H; T_1 \cup T_2 \rightarrow C'; H'; T_1' \cup T_2}{C; H; T_1 \rightarrow C'; H'; T_1'} \;\;\;
\infer[]{C; H; T_1 \cup T_2 \rightarrow C'; H'; T_1 \cup T_2'}{C; H; T_2 \rightarrow C'; H'; T_2'} \;\;\; 
\]

\[%Eval context and fork
\infer[]{C; H; \Theta[L; \eval{e}] \rightarrow C'; H'; \Theta[L'; \eval{e'}] \cup T}{C; H; \Theta[L; e] \rightarrow C'; H'; \Theta[L'; e'] \cup T} \;\;\;
\infer[]{C; H; \Theta[\cdot; \fork{e}] \rightarrow C'; H; \Theta[\cdot; ()] \cup \Theta'[\cdot, e]}{\text{fresh } \Theta'}
\]

\[%Non-transactional read and transactional read not in local domain
\infer[]{C; H; \Theta[\cdot; !\loc] \rightarrow C; H; \Theta[\cdot; v]}{H(\loc) = (v, C')} \;\;\;
\infer[]{C; H; \Theta[L; \aeval{!\loc}] \rightarrow C+1; H; \Theta[L, \loc \mapsto (v, C, \actxt)_R; \aeval{v}]}{\loc \notin Domain(L) \;\;\; H(\loc) = (v, C') } 
\]

\[%transactional read in local domain and non-transactional write
\infer[]{C; H; \Theta[L; \aeval{!\loc}] \rightarrow C; H; \Theta[L; \aeval{v}]}{L(\loc) = (v, C', \actxt') \;\;\; H(\loc) = (v', C'') \;\;\; C' > C''} \;\;\;
\infer[]{C; H; \Theta[L; \aeval{!\loc}] \rightarrow C; H; \Theta[L_o; \actxt'[!\loc]]}{L = L_o, \loc \mapsto (v, C', \actxt')_R, L_r  \;\;\; H(\loc) = (v', C'') \;\;\; C'' > C'} 
\]

\[%non transactional write and transactional write not in domain
\infer[]{C; H; \Theta[\cdot; \loc := v] \rightarrow C+1; H, \loc \mapsto (v, C); \Theta[\cdot; ()]}{}\;\;\;
\infer[]{C; H; \Theta[L; \aeval{\loc := v}] \rightarrow C+1; H; \Theta[L, \loc \mapsto (v, C, \actxt)_W; \aeval{()}]}{\loc \notin Domain(L) \;\;\; H(\loc) = (v', C')} 
\]

\[%transactional write in local domain
\infer[]{C; H; \Theta[L; \aeval{\loc := v}] \rightarrow C; H; \Theta[L, \loc \mapsto (v, C', \actxt')_W; \aeval{()}]}{L(\loc) =  (v', C', \actxt')} \;\;\;
\infer[]{C; H; \Theta[L; \aeval{\atomic{v}}] \rightarrow C; H; \Theta[L; \aeval{v}]}{}
\]

\[%non-transactional and transactional allocation
\infer[]{C; H; \Theta[\cdot; \alloc{v}] \rightarrow C+1; H, \loc \mapsto (v, C); \Theta[\cdot; \loc]}{\loc \text{ is fresh}} \;\;\;
\infer[]{C; H; \Theta[L; \aeval{\alloc{v}}] \rightarrow C+1; H, \loc \mapsto (v, C); \Theta[L;  \aeval{()}]}{\loc \text{ is fresh}}
\]

\[%commit and abort transaction
\infer[]{C; H; \Theta[L; \atomic{v}] \rightarrow C+1; H'; \Theta[\cdot;\cdot; v]}{C; H; \Theta[L; \atomic{v}] \leadsto H'; \Theta[L; \atomic{v}]; \commit} \;\;\;
\infer[]{C; H; \Theta[L; \atomic{v}] \rightarrow C+1; H; \Theta[L'; e]}{C; H; \Theta[L; \atomic{v}] \leadsto H; \Theta[L'; e]; \abort} \;\;\;
\]

%----------------------------------------------------Commit Semantics----------------------------------------------------
\boxed{C; H; \Theta[L; e] \leadsto H', \Theta[L'; e']; (\abort | \commit)}

\[%commit read/write
\infer[]{C; H; \Theta[L, \loc \mapsto (v, C', \actxt)_R; e] \leadsto H'; \Theta[L, \loc \mapsto (v, C', \actxt)_R;e]; \commit}{C; H; \Theta[L; e] \leadsto H'; \Theta[L; e]; \commit \;\;\; H(\loc) = (v, C'') \;\;\; C' > C''} 
\]

\[%abort read
\infer[]{C; H; \Theta[L, \loc \mapsto (v', C',\actxt)_R; e] \leadsto H; \Theta[L; \aeval{!\loc}]; \abort}{C; H; \Theta[L; e] \leadsto H'; \Theta[L; e]; \commit \;\;\; H(\loc) = (v', C'') \;\;\; C'' > C'} \;\;\;
\infer[]{C; H; \Theta[L, \loc \mapsto (v', C',e'')_{op}; e] \leadsto H; \Theta[L'; e']; \abort}{C; H; \Theta[L; e] \leadsto H; \Theta[L'; e']; \abort} 
\]

\[%commit write
\infer[]{C; H; \Theta[L, \loc \mapsto (v, C', \actxt)_W; e] \leadsto H', \loc \mapsto (v, C); \Theta[L, \loc \mapsto (v, C', \actxt)_W; e]; \commit}{C; H; \Theta[L; e] \leadsto H'; \Theta[L; e]; \commit} \;\;\;
\infer[]{C;H;\Theta[\cdot;e] \leadsto H; \Theta[\cdot;e]; \commit}{}
\]

\endgroup

\end{document}
















































