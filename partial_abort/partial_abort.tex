\documentclass[9pt]{article}

\usepackage[margin=.9in]{geometry}

\usepackage{amsmath}
\usepackage{url}
\usepackage{graphicx}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{verbatim}
\usepackage[inference]{semantic}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{color}
\usepackage{amsthm}

\RequirePackage{latexsym,amsmath,amssymb,proof,amsthm,color,
  ifthen,times,enumerate,proof,longtable}

\newcommand{\aeval}[1]{\mathcal{A}[#1]}
\newcommand{\actxt}[0]{\mathcal{A}}
\newcommand{\eval}[1]{\mathcal{E}[#1]}
\newcommand{\ctxt}[0]{\mathcal{E}}
\newcommand{\loc}[0]{\ell}
\newcommand{\atomic}[1]{\text{atomic}(#1)}
\newcommand{\alloc}[1]{\text{ref} \; #1}
\newcommand{\commit}[0]{\text{commit}}
\newcommand{\abort}[0]{\text{abort}}

\begin{document}
\begin{displaymath}
\begin{array}{rcll}
x &\in& Var \\
v &::=& \lambda x. e \; | \; \loc \; | \; () \\
e &::=& v \; | \; x \; | \; e \; e \; | \; !e \; | \; e := e \; | \; \alloc{e} \; | \; \atomic{e}\\
\ctxt &::=& [\cdot] \; | \; \ctxt \; e \; | \; v \; \ctxt \; | \; ! \ctxt \; | \; \ctxt := e \; | \; v := \ctxt \; | \; \alloc{\ctxt} \; | \; \atomic{\actxt}\\
\actxt &::=& [\cdot] \; | \; \actxt \; e \; | \; v \; \actxt \; | \; ! \actxt \; | \; \actxt := e \; | \; v := \actxt \; | \; \alloc{\actxt} \; | \; \atomic{\actxt} \\
H &::=& \cdot \; | \; H, \loc \mapsto v \\
T &::=& \cdot \; | \; \Theta[H; L; e] \; | \; T \cup T \\
L &::=& \cdot \; | \; L, (\loc, v, \actxt) \\
\end{array}
\end{displaymath}

%Note that when a new location is allocated, it needs to be ``globally'' fresh, meaning it is fresh with respect to the heap that everyone has access to as well as all of the local heaps that are private to each thread.  This could be done by maintaining a counter in the program state that gives the next fresh location.

$\boxed{H; T \rightarrow H' ;T'}$
\[
\infer[]{H; T_1 \cup T_2 \rightarrow H'; T_1' \cup T_2}{H; T_1 \rightarrow H'; T_1'} \;\;\;
\infer[]{H; T_1 \cup T_2 \rightarrow H'; T_1 \cup T_2'}{H; T_2 \rightarrow H'; T_2'} \;\;\; 
\infer[]{H; \Theta[H; L; \eval{!\loc}] \rightarrow H; \Theta[H; L; \eval{v}]}{H(\loc) = v}
\]

\[
\infer[]{H; \Theta[H_l; L; \aeval{!\loc}] \rightarrow H; \Theta[H_l, \loc \mapsto v; L, (\loc, v, \aeval{!\loc}); \aeval{v}]}{x \notin Domain(H_l) \;\;\; H(\loc) = v } \;\;\;
\infer[]{H; \Theta[H_l; L; \aeval{!\loc}] \rightarrow H; \Theta[H_l; L; \aeval{v}]}{H_l(\loc) = v }
\]

\[
\infer[]{H; \Theta[H_l; L; \eval{\loc := v}] \rightarrow H, \loc \mapsto v; \atomic{v}\Theta[H_l; L; \eval{()}]}{H(\loc) = v'} \;\;\;
\infer[]{H; \Theta[H_l; L; \aeval{\loc := v}] \rightarrow H; \Theta[H_l[x\mapsto v]; L; \aeval{()}]}{H_l(\loc) = v'}
\]

\[
\infer[]{H; \Theta[H_l; L; \aeval{\loc := v}] \rightarrow H; \Theta[H_l, x\mapsto v; L, (\loc, v, \aeval{\loc := v}); \aeval{()}]}{\loc \notin Domain(H_l) \;\;\; H(\loc) = v'}
\]

\[
\infer[]{H; \Theta[H_l; L; \eval{\alloc{v}}] \rightarrow H, \loc \mapsto v; \Theta[H_l; L; \eval{\loc}]}{\loc \text{ is fresh}} \;\;\;
\infer[]{H; \Theta[H_l; L; \aeval{\alloc{v}}] \rightarrow H; \Theta[H_l, \loc \mapsto v; \aeval{()}]}{\loc \text{ is fresh}}
\]

\[
\infer[]{H; \Theta[H_l; L; \eval{\atomic{v}}] \rightarrow H'; \Theta[\cdot;\cdot; v]}{H; \Theta[H_l; L; \atomic{v}] \leadsto H'; \Theta[H_l; L; \atomic{v}]; \commit} \;\;\;
\infer[]{H; \Theta[H_l; L; \eval{\atomic{v}}] \rightarrow H; \Theta[H_l'; L'; e]}{H; \Theta[H_l; L; \atomic{v}] \leadsto H; \Theta[H_l'; L'; e]; \abort} \;\;\;
\]

%----------------------------------------------------Commit Semantics----------------------------------------------------
\boxed{H; \Theta[H_l; L; e] \leadsto H', \Theta[H_l'; L'; e']; (\abort | \commit)}

\[
\infer[]{H; \Theta[H_l, \loc \mapsto v'; L, (\loc,v,e'); e] \leadsto H', \loc \mapsto v'; \Theta[H_l, \loc \mapsto v'; L, (\loc, v, e');e]; \commit}{H; \Theta[H_l; L; e] \leadsto H'; \Theta[H_l; L; e]; \commit \;\;\; H(\loc) = v}
\]

\[
\infer[]{H; \Theta[H_l, \loc \mapsto v'; L, (\loc,v,e'); e] \leadsto H; \Theta[H_l; L; e']; \abort}{H; \Theta[H_l; L; e] \leadsto H'; \Theta[H_l; L; e]; \commit \;\;\; H(\loc) \not= v} \;\;\;
\infer[]{H; \Theta[H_l, \loc \mapsto v'; L, (\loc,v,e'); e] \leadsto H'; \Theta[H_l'; L'; e']; \abort}{H; \Theta[H_l; L; e] \leadsto H'; \Theta[H_l'; L'; e']; \abort}
\]

\end{document}
















































