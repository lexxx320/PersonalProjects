\documentclass[9pt]{article}

\usepackage[margin=.9in]{geometry}

\usepackage{amsmath}
\usepackage{url}
\usepackage{graphicx}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{verbatim}
\usepackage[inference]{semantic}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{color}
\usepackage{amsthm}

\RequirePackage{latexsym,amsmath,amssymb,proof,amsthm,color,
  ifthen,times,enumerate,proof,longtable}

\newcommand{\aeval}[1]{\mathcal{A}[#1]}
\newcommand{\actxt}[0]{\mathcal{A}}
\newcommand{\eval}[1]{\mathcal{E}[#1]}
\newcommand{\ctxt}[0]{\mathcal{E}}
\newcommand{\loc}[0]{\ell}
\newcommand{\atomic}[1]{\text{atomic}(#1)}
\newcommand{\alloc}[1]{\text{ref} \; #1}
\newcommand{\commit}[0]{\text{commit}}
\newcommand{\abort}[0]{\text{abort}}
\newcommand{\fork}[1]{\text{fork } #1}

\begin{document}
\begingroup\makeatletter\def\f@size{9}\check@mathfonts


\begin{displaymath}
\begin{array}{rcll}
\text{Variables } \;\;\; x &\in& Var \\
\text{Values } \;\;\; v &::=& \lambda x. e \; | \; \loc \; | \; () \\
\text{Expressions } \;\;\; e &::=& v \; | \; x \; | \; e \; e \; | \; !e \; | \; e := e \; | \; \alloc{e} \; | \; \fork{e} \; | \; \atomic{e}\\
\text{Non-Transactional Context } \;\;\; \ctxt &::=& [\cdot] \; | \; \ctxt \; e \; | \; v \; \ctxt \; | \; ! \ctxt \; | \; \ctxt := e \; | \; v := \ctxt \; | \; \alloc{\ctxt} \\
\text{Transactional Context } \;\;\; \actxt &::=& [\cdot] \; | \; \actxt \; e \; | \; v \; \actxt \; | \; ! \actxt \; | \; \actxt := e \; | \; v := \actxt \; | \; \alloc{\actxt} \; | \; \atomic{\actxt} \\
\text{Heap } \;\;\; H &::=& \cdot \; | \; H, \loc \mapsto v \\
\text{Thread Pool} \;\;\; T &::=& \cdot \; | \; \Theta[H; L; e] \; | \; T \cup T \\
\text{Transactional Log } \;\;\; L &::=& \cdot \; | \; L, (\loc, v, e)_{op} \\
\text{Operations } \;\;\; op &::=& R \; | \; W \; | \; A \\
\end{array}
\end{displaymath}

$\boxed{H; T \rightarrow H' ;T'}$
\[%Parallel composition and non-transactional eval ctxt
\infer[]{H; T_1 \cup T_2 \rightarrow H'; T_1' \cup T_2}{H; T_1 \rightarrow H'; T_1'} \;\;\;
\infer[]{H; T_1 \cup T_2 \rightarrow H'; T_1 \cup T_2'}{H; T_2 \rightarrow H'; T_2'} \;\;\; 
\]

\[%Eval context and fork
\infer[]{H; \Theta[H_l; L; \eval{e}] \rightarrow H'; \Theta[H_l'; L'; \eval{e'}] \cup T}{H; \Theta[H_l; L; e] \rightarrow H'; \Theta[H_l'; L'; e'] \cup T} \;\;\;
\infer[]{H; \Theta[H_l, L, \fork{e}] \rightarrow H; \Theta[H_l, L, ()] \cup \Theta'[\cdot, \cdot, e]}{}
\]

\[%Non-transactional read and transactional read not in local domain
\infer[]{H; \Theta[H_l; L; !\loc] \rightarrow H; \Theta[H_l; L; v]}{H(\loc) = v} \;\;\;
\infer[]{H; \Theta[H_l; L; \aeval{!\loc}] \rightarrow H; \Theta[H_l, \loc \mapsto v; L, (\loc, v, \aeval{!\loc})_R; \aeval{v}]}{\loc \notin Domain(H_l) \;\;\; H(\loc) = v } 
\]

\[%transactional read in local domain and non-transactional write
\infer[]{H; \Theta[H_l; L; \aeval{!\loc}] \rightarrow H; \Theta[H_l; L; \aeval{v}]}{H_l(\loc) = v } \;\;\;
\infer[]{H; \Theta[H_l; L; \loc := v] \rightarrow H, \loc \mapsto v; \Theta[H_l; L; ()]}{}
\]

\[%transactional write not in local domain 
\infer[]{H; \Theta[H_l; L; \aeval{\loc := v}] \rightarrow H; \Theta[H_l, \loc \mapsto v; L, (\loc, v, \aeval{\loc := v})_W; \aeval{()}]}{\loc \notin Domain(H_l) \;\;\; H(\loc) = v'} 
\]

\[%transactional write in local domain
\infer[]{H; \Theta[H_l; L; \aeval{\loc := v}] \rightarrow H; \Theta[H_l, \loc \mapsto v; L, (\loc,v,\aeval{\loc := v})_W; \aeval{()}]}{H_l(\loc) = v'} 
\]

\[%non-transactional and transactional allocation
\infer[]{H; \Theta[H_l; L; \alloc{v}] \rightarrow H, \loc \mapsto v; \Theta[H_l; L; \loc]}{\loc \text{ is fresh}} \;\;\;
\infer[]{H; \Theta[H_l; L; \aeval{\alloc{v}}] \rightarrow H; \Theta[H_l, \loc \mapsto v; L, (\loc, v, \aeval{\alloc{v}})_A;  \aeval{()}]}{\loc \text{ is fresh}}
\]

\[%commit and abort transaction
\infer[]{H; \Theta[H_l; L; \atomic{v}] \rightarrow H'; \Theta[\cdot;\cdot; v]}{H; \Theta[H_l; L; \atomic{v}] \leadsto H'; \Theta[H_l; L; \atomic{v}]; \commit} \;\;\;
\infer[]{H; \Theta[H_l; L; \atomic{v}] \rightarrow H; \Theta[H_l'; L'; e]}{H; \Theta[H_l; L; \atomic{v}] \leadsto H; \Theta[H_l'; L'; e]; \abort} \;\;\;
\]

\[%nested transaction (idempotent)
\infer[]{H; \Theta[H_l; L; \aeval{\atomic{v}}] \rightarrow H; \Theta[H_l; L; \aeval{v}]}{}
\]

%----------------------------------------------------Commit Semantics----------------------------------------------------
\boxed{H; \Theta[H_l; L; e] \leadsto H', \Theta[H_l'; L'; e']; (\abort | \commit)}

\[%commit read/write
\infer[]{H; \Theta[H_l, \loc \mapsto v; L, (\loc,v,e')_{op}; e] \leadsto H'; \Theta[H_l, \loc \mapsto v; L, (\loc, v, e')_{op};e]; \commit}{H; \Theta[H_l; L; e] \leadsto H'; \Theta[H_l; L; e]; \commit \;\;\; H(\loc) = v \;\;\; op = R|W}
\]

\[%abort read
\infer[]{H; \Theta[H_l, \loc \mapsto v'; L, (\loc,v,e')_{op}; e] \leadsto H; \Theta[H_l; L; e']; \abort}{H; \Theta[H_l; L; e] \leadsto H'; \Theta[H_l; L; e]; \commit \;\;\; H(\loc) \not= v \;\;\; op=R|W} 
\]

\[%commit write/allocation and propogate 
\infer[]{H; \Theta[H_l, \loc \mapsto v'; L, (\loc,v,e')_A; e] \leadsto H', \loc \mapsto v'; L, (\loc,v,e')_A; e]; \commit}{H; \Theta[H_l; L; e] \leadsto H'; \Theta[H_l; L; e]; \commit} \;\;\;
\infer[]{H; \Theta[H_l, \loc \mapsto v'; L, (\loc,v,e')_{op}; e] \leadsto H; \Theta[H_l'; L'; e']; \abort}{H; \Theta[H_l; L; e] \leadsto H; \Theta[H_l'; L'; e']; \abort} 
\]

\endgroup

\end{document}
















































