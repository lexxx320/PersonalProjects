\documentclass[9pt]{article}
\RequirePackage{latexsym,amsmath,amssymb,proof,amsthm,color,
  ifthen,times,enumerate,proof,longtable}


\usepackage[margin=.9in]{geometry}
\usepackage{bussproofs}
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{syntax}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage[inference]{semantic}
\usepackage{verbatim}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\newcommand\specStep{\rightarrow_{s}}
\newcommand\parStep{\rightarrow_{p}}
\newcommand{\eval}[1]{E[#1]}
\newcommand\plusplus{+\kern-0.5ex+\kern0.8ex}
\newcommand{\erase}[1]{\mathcal{E}\llbracket #1 \rrbracket}
\newcommand{\eraseThreads}[2]{\mathcal{ET}\llbracket #1, #2 \rrbracket}
\newcommand{\eraseHeap}[1]{\mathcal{EH}\llbracket #1 \rrbracket}
\newcommand{\unSpec}[1]{\mathcal{US} \llbracket #1 \rrbracket}
\newcommand{\specActions}[1]{\mathcal{SA} \llbracket #1 \rrbracket}
\newcommand{\commitActions}[1]{\mathcal{CA} \llbracket #1 \rrbracket}
\newcommand{\seq}[1]{\mathcal{S}\llbracket #1 \rrbracket}
\title{Techincal Appendix}
\author{Matthew Le}
\begin{document}
\maketitle

\section{Syntax}

\begin{displaymath}
\begin{array}{rcll}
x &\in& IVar \\
i, j &\in& StepCount  \\ 

Values \;\;\;\; v & ::= & x \; | \; i \; | \; \backslash x. M \\
& | & return \; M\\ 
& | & M >>= N\\
& | & runPar \; M \\
& | & fork \; M \\
& | & new \\
& | & put \; i \; M \\
& | & get \; i \\ 
& | & done \; M \\
& | & spec \; M \; N \\
& | & specReturn(M, wait \; \Theta) \\
& | & raise \; M \\
& | & handle \; M \; N  \\

TID \;\;\; \Theta &::=& \cdot \; | \; \Theta : Maj_{min} \\

Terms \;\;\; M, N &::=&  V \;| \;M \; N \; | \; \cdots\\

Heap \;\;\; H &::=& H, x \mapsto iv \; | \; \cdot \\

ivarState \;\;\; iv &::=& \langle\rangle_x^{sc} \; | \; \langle ds, s, \Theta, M\rangle_x^{sc}\\

specStack \;\;\;\; S &::=& \cdot \; | \; S : A\; \\
specAction \;\;\;\; A &::=& (j, M)_r^x \; | \; (j, M)_w^x \; | \; (j, M)_s^x \; | \; (j, M)_c^x \; | \; (j, M)_f^{\Theta_i} \; | \; spec \; | \; join\\

configuration \;\;\;\; \sigma &::=& H; T \; | \; Error\\

Evaluation Context \;\;\;\; \mathcal{E} &::=& [\cdot] \; | \; \mathcal{E} >>= M \; | \; specReturn(\mathcal{E}, M) \; | \; handle \; \mathcal{E} \; N
\end{array}
\end{displaymath}

\[
\infer[]{\cdot : K_i : \Theta_{i'} \sqsubseteq \cdot : K_j : \Theta_{j'}'}{i \le j, \;\;\; \cdot : \Theta_{i'} \sqsubseteq \cdot : \Theta_{j'}} \;\;\;
\infer[]{\cdot \sqsubseteq \Theta_j' }{} \;\;\;
\infer[]{\cdot : K_i : \Theta_{i'} \le \cdot : K'_j : \Theta_j'}{K < K' \;\;\; \cdot \Theta_{i'} \le \Theta_{j'}'} \;\;\;
\infer[]{\cdot : K_i : \Theta_{i'} \le \cdot : K'_j : \Theta_j'}{K \le K' \;\;\; i \le j \;\;\; \cdot \Theta_{i'} \le \Theta_{j'}'} \;\;\;
\infer[]{\cdot \le \Theta_j'}{}
\]

\section{Operational Semantics}

\begin{displaymath}
\begin{array}{rcll}
P \; | \; Q &\equiv& Q \; | \; P \\
P \; | \; (Q \; | \; R) &\equiv& (P \; | \; Q) \; | \; R \\
\end{array}
\end{displaymath}

\[
\infer[]{H; P \rightarrow H'; Q}{P \equiv P' \;\;\; H; P' \rightarrow H'; Q}
\]

\[
\infer[]{DeadLocked(H; T_1 \; | \; T_2)}{DeadLocked(H; T_1) \; | \; DeadLocked(H; T_2)} \;\;\;
\infer[]{DeadLocked(H; \Theta_i[S_1, S_2, \eval{get \; x}]}{H(x) = \langle\rangle_x^c}
\]

\newpage

\[%RunPar
\infer[\text{SRunPar}]{\text{runPar } M \Downarrow V}{\cdot; 1_1[\cdot, \cdot, M >>= \backslash x. done \; x] \rightarrow^* H'; T \; | \; 1_n[\cdot, S_2, done \; N] , \;\;\; N \Downarrow V, \;\;\; DeadLocked(T)}
\]

$\boxed{\sigma \rightarrow \sigma} $

\[%Eval and Bind
\infer[\text{SEval}]{H; \Theta_i[S_1, S_2, \eval{M}] \; | \; T  \rightarrow H; \Theta_{i+1}[S_1, S_2, \eval{V}] \; | \; T}{M \neq V \;\;\; M \Downarrow V} 
\]

\[
\infer[\text{SBind}]{H; \Theta_i[S_1, S_2,  \eval{return \; N >>= M}] \; | \; T \rightarrow  H; \Theta_{i+1}[S_1, S_2, \eval{M \; N}] \; | \; T}{} 
\]

\[%Fork
\infer[\text{SFork}]{H; \Theta_i[S_1, S_2, \eval{fork \; M}] \; | \; T \rightarrow H; \Theta_{i+1}[(i, \eval{fork \; M})_f^{\Theta_i : 1_1} : S_1, S_2 , \eval{return()}] \; | \; \Theta_i : 1_1[spec, \cdot, M] \; | \; T}{}
\]

\[%Create ivar
\infer[\text{SNew}]{H; \Theta_i[S_1, S_2, \eval{new}] \; | \; T \rightarrow H';  \Theta_{i+1}[(i, \eval{new})_c^x : S_1, S_2, \eval{return \; x}] \; | \; T}{H' = H[x \mapsto \langle\rangle_x^s] \;\;\; y \notin Domain(H)}
\]

\[%Read form IVar
\infer[\text{SGet}]{H; \Theta_i[S_1, S_2, \eval{get \; x}] \; | \; T \rightarrow H'; \Theta_{i+1}[(i, \eval{get \; x})_r^x : S_1, S_2, \eval{return \; M}] \; | \; T}{H(x) = \langle ds, S, \Theta_j', M\rangle_x^{sc}, \;\;\; \Theta_j' \le \Theta_i, \;\;\; H' = H[x \mapsto \langle \Theta_i \uplus ds, S_1, \Theta_j', M\rangle_x^{sc}]}
\]

\[%Put
\infer[\text{SPut}]{H; \Theta_i[S_1, S_2, \eval{put \; x \; M}] \; | \; T \rightarrow H'; \Theta_{i+1}[(i, \eval{put \; x \; M})_w^x : S_1, S_2, \eval{return()}] \; | \; T}{H(x) = \langle\rangle_x^{sc}, \;\;\; H' = H[x \mapsto \langle \emptyset, S_1, \Theta_i, M\rangle_x^{sc}]}
\]

\[%Overwrite
\inference[\text{Overwrite}]{H(x) = \langle ds, S:A, \Theta_j', N\rangle, \;\;\; rollback(\Theta_j', H, T) \leadsto (H', T'), \;\;\; H'' = H'[x\mapsto\langle \emptyset, \cdot, \Theta_i, M\rangle]}{H; \Theta_i[\cdot, S_2, \eval{put \; x \; M}] \; | \; T \rightarrow H'; \Theta_{i+1}[\cdot, S_2, \eval{return ()}] \; | \; T'}
\]

\[%ErrorWrite
\infer[\text{ErrorWrite}]{H; \Theta_i[\cdot, S_2, \eval{put \; x \; M}] \; | \; T \rightarrow Error}{H(x) = \langle ds, \cdot, \Theta_j', N\rangle}
\]

\[ %Spec
\infer[\text{Spec}]{H; \Theta_i[S_1, S_2, \eval{spec \; M \; N}] \; | \; T \rightarrow H; \Theta_{i+1}[(i, \eval{spec \; M \; N})_f^{\Theta_i : 1_1} : S_1, S_2, \eval{specReturn(M, wait \; \Theta_i : 1_1)}] \; | \; T')}{T' = \Theta_i : 1_1[\cdot : (1, N)_s : spec, \cdot, N] \; | \; T}
\]

\[%Pop Spec
\inference[\text{PopSpec}]{}{\begin{array}{l} H; \Theta_i[\cdot, S_2, \eval{specReturn(return \; N_1, M_0, wait \; \Theta_1')}]  \; | \; \Theta_j'[S_1' : (1, M)_s, S_2, return \; N_2] \; | \; T \rightarrow \\ H; \Theta_{i+1}[\cdot, S_2, \eval{specReturn(return \; N_1, wait \; \Theta_1')}] \; | \; \Theta_{j+1}'[join : S_1', (1, M)_s : S_2', return \; N_2] \; | \; T \end{array}}
\]

\[%Spec Join
\inference[\text{SpecJoin}]{}{\begin{array}{l} H; T \; | \; \Theta_i[\cdot, S_2, \eval{specReturn(return \; N_1, wait \; \Theta_1')}] \; | \; \Theta_j'[\cdot : join, S_2, return \; N_2]) \rightarrow \\ H; T \; | \; \Theta_{i+1}[\cdot, S_2, \eval{return(N_1, N_2)}] \end{array}}
\]

\[%Spec Rollback
\infer[\text{SpecRB}]{H; \Theta_i[S_1, S_2, \eval{specReturn(raise \; M, wait \; \Theta_j')}] \; | \; \Theta_j'[S_1', S_2', M] \; | \; T \rightarrow H'; \Theta_{i+1}[S_1, S_2, \eval{raise \; M}] \; | \; T'}{rollback(\Theta_i, H, T \; | \; \Theta_j'[S_1', S_2', M]) \leadsto (H', \Theta_{j'}'[\cdot : (j'', M''), S_2'', M'] \; | \; T')}
\]

\[%Spec Raise
\infer[\text{SpecRaise}]{H; \Theta_i[\cdot, S_2, \eval{specReturn(return \; N_1, wait \; \Theta_1')}] \; | \; \Theta_j'[\cdot, S_2', raise \; M] \; | \; T \rightarrow H; \Theta_{i+1}[\cdot, S_2, \eval{raise \; M}] \; | \; T}{}
\]

\[%Raise
\infer[\text{Raise}]{H; \Theta_i[S_1, S_2, \eval{raise \; E >>= M}] \; | \; T \rightarrow H; \Theta_{i+1}[S_1, S_2, \eval{raise \; E}] \; | \; T}{}
\]

\[%Handle
\infer[\text{Handle}]{H; \Theta_i[S_1, S_2, \eval{handle (raise \; M) N}] \; | \; T \rightarrow H; \Theta_{i+1}[S_1, S_2, \eval{N \; M}] \; | \; T}{}
\]

\[%Pop a read and a write action from the deque
\infer[\text{PopRead}]{H; \Theta_i[S_1 : (i', N')_r^x, S_2, N] \; | \; T \rightarrow H; \Theta_{i+1}[S_1, (i', N')_r^x : S_2, N] \; | \; T)}{H(x) = \langle ds, \cdot, \Theta_j', M\rangle_x^c}
\]

\[%Pop Write
\infer[\text{PopWrite}]{H; \Theta_i[S_1: (i', N')_w^x, S_2, N] \; | \; T \rightarrow H'; \Theta_{i+1}[S_1, (i', N')_w^x : S_2, N] \; | \; T)}{H(x) = \langle ds, S, \Theta_i', M\rangle_x^c, \;\;\; H' = H[x \mapsto \langle ds, \cdot, \Theta_i', M\rangle_x^c]}
\]

\[%Pop new Full
\infer[\text{PopNewFull}]{H; \Theta_i[S_1 : (i', N')_c^x, S_2, N] \; | \; T \rightarrow H';  \Theta_{i+1}[S_1, (i', N')_c^x : S_2, N] \; | \; T}{H(x) = \langle ds, S:A, \Theta_j', M \rangle_x^s, \;\;\; H' = H[x \mapsto \langle ds, S:A, \Theta_j', M\rangle_x^c]}
\]

\[%Pop new Empty
\infer[\text{PopNewEmpty}]{H; \Theta_i[S_1 : (i', N')_c^x, S_2, N] \; | \; T \rightarrow H';  \Theta_{i+1}[S_1, (i', N')_c^x : S_2, N] \; | \; T}{H(x) = \langle \rangle_x^s, \;\;\; H' = H[x \mapsto \langle \rangle_x^c]}
\]

\[%Pop Fork
\infer[\text{PopFork}]{H; \Theta_i[S_1 : (i', M')_f^{\Theta_j'}, S_2, M] \; | \; \Theta_{j'}'[S_1' : spec, S_2', N] \; | \; T \rightarrow H; \Theta_{i+1}[S_1, (i', M')_f^{\Theta_j'} : S_2, M] \; | \; \Theta_{j' + 1}'[S_1', spec : S_2', N] \; | \; T}{}
\]

\[
\infer[\text{Terminate}]{H; \Theta_i[\cdot, S_2, return \; M] \; | \; T \specStep H; T}{}
\]

%----------------------------------------------------------------------------------------------Rollback rules--------------------------------------------------------------------------------

$\boxed{rollback(\Theta_i, H, T) \leadsto (H' ,T')}$

\[%Rollback Finish
\infer[\text{RBDone}]{rollback(\Theta_i, H, \Theta_{i'}[(i'', M')_s, S_2, M] \; | \; T) \leadsto (H, \Theta_{i'}[(i'', M')_s, S_2, M] \; | \; T)}{}
\]

\[%Rollback Read
\infer[\text{RBRead}]{rollback(\Theta_i, H, \Theta_j'[(j', M')_r^x : S_1, S_2, M] \; | \; T) \leadsto (H'', T')}{H(x) = \langle \Theta_{j'}' \uplus ds, s, t, M\rangle, \;\;\; H' = H[x \mapsto \langle ds, s, t, M\rangle] \;\;\; rollback(\Theta_i, H', \Theta_{j'}'[S_1, S_2, M'] \; | \; T) \leadsto (H'', T')}
\]

\[%Rollback Fork
\infer[\text{RBFork}]{rollback(\Theta_i, H, \Theta_j'[(j', M')_f^{\Theta_k''} : S_1, S_2, M] \; | \; \Theta_{k'}''[spec, S_2', M''] \; | \; T) \leadsto (H', T')}{rollback(\Theta_i, H, \Theta_{j'}'[S_1, S_2, M'] \; | \; T) \leadsto (H', T')}
\]

\[%Rollback Write
\infer[\text{RBWrite}]{rollback(\Theta_i, H, \Theta_j'[(j', M')_w^x : S_1, S_2, M] \; | \; T) \leadsto (H'', T')}{H(x) = \langle \emptyset, s, t, M\rangle_x, \;\;\; H' = H[x \mapsto \langle\rangle_x] \;\;\; rollback(\Theta_i, H', \Theta_{j'}'[S_1, S_2, M'] \; | \; T) \leadsto (H'', T')}
\]

\[%Rollback Created Ivar
\infer[\text{RBNew}]{rollback(\Theta_i, H, \Theta_j'[(j', M')_c^x : S_1, S_2, M] \; | \; T) \leadsto (H'', T')}{H(x) = \langle\rangle_x, \;\;\; H' = H \backslash x \;\;\; rollback(\Theta_i, H', \Theta_{j'}'[S_1, S_2, M'] \; | \; T) \leadsto (H'', T')}
\]

\[%Rollback Spec
\infer[\text{RBSpec}]{rollback(\Theta_i, H, \Theta_j'[(j', M')_f^{\Theta_{k'}''} : S_1, S_2, M] \; | \; \Theta_k''[(k', N')_s : spec, \cdot, N] \; | \; T) \leadsto (H'', T'')}{rollback(\Theta_i, H, \Theta_j'[S_1, S_2, M] \; | \; T) \leadsto (H'', T'')}
\]


\section{Proof of Determinism}



\begin{figure}[H]
\centering

\begin{displaymath}
\begin{array}{rcll}
\erase{H; T} &=& \eraseHeap{H}; \eraseThreads{T}{T} \\
\eraseThreads{T_1 \; | \; T_2}{T} &=& \eraseThreads{T_1}{ T} \; | \; \eraseThreads{T_2}{ T} \\
\eraseThreads{\Theta_i[S_1 : (i', M')_s, S_2, M]}{T} &=& \cdot \\
\eraseThreads{\Theta_i[S_1 : (i', M')_{action}^x, S_2, M]}{T} &=& \eraseThreads{M'}{T} \;\;\; action \neq s\\

\eraseThreads{ spec \; M \; N}{T} &=& \eraseThreads{M}{T} >>= \backslash i . \eraseThreads{N}{T} >>= \backslash j. return(i, j) \\
\eraseThreads{specReturn(M, wait \; \Theta_i)}{T} &=& \eraseThreads{M}{T} >>= \backslash i. \eraseThreads{T(\Theta_i)}{T} >>= \backslash j. return(i, j) \\
\eraseThreads{M >>= N}{T} &=& \eraseThreads{M}{T} >>= \eraseThreads{N}{T}\\
\eraseThreads{runPar \; M}{T} &=& runPar \; \eraseThreads{M}{T} \\
\eraseThreads{fork \; M}{T} &=& fork \; \eraseThreads{M}{T} \\
\eraseThreads{new}{T} &=& new \\
\eraseThreads{put \; i \; M}{T} &=& put \; i \; \eraseThreads{M}{T} \\
\eraseThreads{get \; i}{T} &=& get \; i \\
\eraseThreads{raise \; M}{T} &=& raise \; \eraseThreads{M}{T} \\
\eraseThreads{handle \; M \; N}{T} &=& handle \; \eraseThreads{M}{T} \; \eraseThreads{N}{T}  \\

\eraseHeap{H, x \mapsto \langle\rangle_x^s} &=& \eraseHeap{H} \\
\eraseHeap{H, x \mapsto \langle ds, s, tid, M\rangle_x^s} &=& \eraseHeap{H} \\
\eraseHeap{H, x \mapsto \langle\rangle_x^c} &=& \eraseHeap{H}, x\mapsto \langle\rangle_x \\
\eraseHeap{H, x\mapsto \langle ds, S : A, tid, M\rangle_x^c} &=& \eraseHeap{H}, x \mapsto \langle\rangle_x \\
\eraseHeap{H, x \mapsto \langle ds, \cdot, tid, M\rangle_x^c} &=& \eraseHeap{H}, x \mapsto \langle M\rangle_x \\
\end{array}
\end{displaymath}
\caption{Erasure}
\end{figure}

$\boxed{\specActions{T} \leadsto specStack} $ 

\[
\infer[]{\specActions{T_1 \; | \; T_2} \leadsto specActions}{\specActions{T_1} \leadsto a_1, \;\;\; \specActions{T_2} \leadsto a_2, \;\;\; specActions = a_1 \cup a_2} \;\;\; 
\infer[]{\specActions{\Theta_i[S_1, S_2, M]} \leadsto specActions}{specActions = \{(\Theta_0, S_1 )\}} \;\;\;
\]

$\boxed{\commitActions{T} \leadsto commitStack} $ 

\[
\infer[]{\commitActions{T_1 \; | \; T_2} \leadsto commitActions}{\commitActions{T_1} \leadsto a_1, \;\;\; \commitActions{T_2} \leadsto a_2, \;\;\; commitActions = a_1 \cup a_2} \;\;\; 
\infer[]{\commitActions{\Theta_i[S_1, S_2, M]} \leadsto commitActions}{commitActions = \{(\Theta_0, S_2 )\}} \;\;\;
\]

Note: we use $H; T \parStep H'; T'$ to denote a step in the non-speculative (par monad) semantics and $H; T \specStep H; T'$ to denote a step in the speculative semantics. 

%Nonspeculative Implies Speculative Execution
\begin{theorem}[Non-speculative implies speculative]
For all $M$, if $runPar \; M \Downarrow_p V$, then there exists some $M', V'$, such that $runPar M' \Downarrow V'$, where $\erase{M'} = M$ and $\erase{V' = V}$

\end{theorem}

\begin{proof}

By inversion of $runPar \; M$, we have $\cdot; M >>= \backslash x. done \; x \parStep^* H; T \; | \; done \; N, N \Downarrow_p V$, and $DeadLocked(T)$
After applying Lemma \ref{RunParStar} to $\cdot; \erase{M} >>= \backslash x. done \; x \parStep^* done \; N$, we get $\erase{\Theta_i[ws, rs, \cdot, done \; N']} = done \; N$.  From $\erase{\Theta_i[ws, rs, \cdot, done \; N']} = done \; N$, we get $N' = N$, which implies that $N' \Downarrow V = V'$, which establishes the result.

\end{proof}

%Nonspeculative Implies Speculative *
\begin{lemma}[Nonspeculative Implies Speculative Star]
\label{RunParStar}
For all $H_{par}, H_{par}', T_{par}, T_{par}'$, if $H_{par}; T_{par} \parStep^* H_{par}'; T_{par}'$, then $\exists H_{spar}, H_{spar}', T_{spar}, T_{spar}'$, such that 
\begin{enumerate}
\item $H_{spar}; T_{spar} \parStep^* H_{spar}'; T_{spar}'$
\item $\erase{H_{spar}} = H_{par}$
\item  $\erase{H_{spar}'} = H_{par}'$
\item $\erase{T_{spar}} = T_{par}$
\item $\erase{T_{spar}'} = T_{par}'$
\end{enumerate}
\end{lemma}

%Proof of non speculative Implies Speculative *
\begin{proof}
By induction on $H_{par}; T_{par} \parStep^* H_{par}'; T_{par}'$

\begin{itemize}
\item $H_{par}; T_{par} \parStep^* H_{par}'; T_{par}' \equiv H_{par}; T_{par} \parStep^0 H_{par}; T_{par}$ -- this case holds trivially

\item $H_{par}; T_{par} \parStep^* H_{par}'; T_{par}' \equiv H_{par}; T_{par} \parStep H_{par}^\dagger; T_{par}^\dagger \parStep^* H_{par}'; T_{par}'$.  From the induction hypothesis we have $\exists T_{spar}^\dagger, T_{spar}', H_{spar}^\dagger, H_{spar}', H_{spar}^\dagger; T_{spar}^\dagger \specStep H_{spar}'; T_{spar}'$ and by applying Lemma \ref{StructuralStep} to $H_{par}; T_{par} \parStep H_{par}^\dagger; T_{par}^\dagger$, we have $\exists H_{spar}, H_{spar}$
\end{itemize}
\vspace{-2em}
\end{proof}
%Nonspeculative Implies Speculative Step
\begin{lemma}[Nonspeculative Implies Speculative Step]
\label{StructuralStep}
For all $T_{spar}, T_{par}'$, if $\mathcal{E} \llbracket T_{spar}\rrbracket \parStep T_{par}'$, then there exists $T_{spar}'$, such that $T_{spar} \specStep T_{spar}'$ and $\mathcal{E}\llbracket T_{spar}'\rrbracket = T_{par}'$
\end{lemma}
%Proof of Nonspeculative Implies Speculative Step
\begin{proof}
Proven in Coq
\end{proof}

%Speculative implies non-speculative execution.  
%\begin{theorem}[Speculative implies non-speculative]
%For all $M$, if $\cdot; 1_1[\cdot, \cdot, M >>= \backslash x. done \; x] \specStep^* H; 1_i[\cdot, S_2, done \; N] \; | \; T$, then $\erase{\cdot; 1_1[\cdot, \cdot, M >>= \backslash x. done \; x]} \parStep^* \erase{H; 1_i[\cdot, S_2, done \; N] \; | \; T}$
%
%\end{theorem}
%
%%Proof of Speculative implies non-speculative execution.
%\begin{proof}
%
%\end{proof}

%SpecStep*
\begin{lemma}[SpecStep*]
\label{specStepStar}
For all $H, H', T, T'$, if $WF(H; T)$ and $H; T \specStep^* H'; T'$, then $\erase{H; T} \parStep^* \erase{H'; T'}$ and $WF(H'; T')$
\end{lemma}

%Proof of SpecStep*
\begin{proof}
by induction on the number of steps taken in the derivation:
\begin{itemize}
\item n = 0 -- This case holds trivially
\item n = m+1 -- By the inductive hypothesis, we have $H; T \specStep^* H^\dagger; T^\dagger \specStep H'; T', \erase{H; T} \specStep^* \erase{H^\dagger; T^\dagger}$ and $WF(H^\dagger; T^\dagger)$.  By applying Lemma \ref{specStep} to $WF(H^\dagger; T^\dagger)$ and $H^\dagger; T^\dagger \specStep H'; T'$, we get
$\erase{H^\dagger; T^\dagger} \parStep \erase{H'; T'}$ and $WF(H'; T')$
\end{itemize}
\end{proof}

%SpecRunPar Step
\begin{lemma}[SpecStep]
\label{specStep}
For all $H, H', T_{spar}, T_{spar}'$, if $WF(H; T_{spar})$ and $H; T_{spar} \specStep H'; T_{spar}'$, then $\erase{H; T_{spar}} \parStep \erase{H'; T_{spar}'}$ and $WF(H'; T_{spar}')$

\end{lemma}

%Proof of SpecRunPar Step
\begin{proof}
By cases on $H; T_{spar} \specStep H'; T_{spar}'$

\begin{itemize}

%Pop Read
\item $\infer[\text{PopRead}]{H; \Theta_i[S_1 : (i', N')_r^x, S_2, N] \; | \; T \rightarrow H; \Theta_{i+1}[S_1, (i', N')_r^x : S_2, N] \; | \; T)}{H(x) = \langle ds, \cdot, \Theta_j', M\rangle_x^c}$

Let $N_{erase} = \erase{\Theta_{i+1}[S_1, (i', N')_r^x : S_2, N]}$.  From $WF(H; \Theta_i[S_1 : (i', N')_r^x \; | \; T)$, we have:

$\unSpec{H}; \Theta_{i'}[\cdot, S_2, N'] \; | \ \unSpec{T} \specStep H^\dagger; \Theta_{i'+1}[(i', N'), S_2, N^\dagger] \; | \; \unSpec{T} \specStep^* H^\ddagger; \Theta_{i''}[(i', N'), S_2, N_{erase}] \; | \; T^\dagger \specStep^*$

$H; \Theta_i[S_1 : (i', N')_r^x, S_2, N \; | \; T$

Applying Lemma \ref{nonSpecPureStep} to $H^\dagger; \Theta_{i'+1}[(i', N'), S_2, N^\dagger] \; | \; \unSpec{T} \specStep^* H^\ddagger; \Theta_{i''}[(i', N'), S_2, N_{erase}] \; | \; T^\dagger$, we have $\erase{H^\dagger}; \erase{N^\dagger} \; | \; \erase{T} \parStep^* \erase{H^\ddagger}; \erase{N_{erase}} \; | \; \erase{T^\dagger}$.  Since the only way of adding a read action to a thread's stack, is with the SGet rule, we know that $N' \equiv \eval{get \; x}$ and $N^\dagger \equiv \eval{return \; M}$.  Also, Since $H(x) = \langle ds, \cdot, \Theta_j', M\rangle_x^c$, we have $\erase{H}(x) = \langle M\rangle_x$.  Therefore, we can construct the derivation for 

$\erase{H}; \erase{\eval{get \; x}} \; | \; \erase{T} \parStep \erase{H^\dagger}; \erase{\eval{return \; M}} \; | \; \erase{T}$.  which then also yields

$\erase{H}; \erase{\eval{get \; x}} \; | \; \erase{T} \parStep \erase{H^\dagger}; \erase{\eval{return \; M}} \; | \; \erase{T} \parStep^*  \erase{H^\ddagger}; \erase{N_{erase}} \; | \; \erase{T^\dagger}$

Finally, from Lemma \ref{wfIntermediate} we have $\erase{H^\ddagger} = \erase{H}$ and $\erase{T^\dagger} = \erase{T}$, we have 

$\erase{H}; \erase{\eval{get \; x}} \; | \; \erase{T} \parStep \erase{H^\dagger}; \erase{\eval{return \; M}} \; | \; \erase{T} \parStep^*  \erase{H}; \erase{N_{erase}} \; | \; \erase{T}$, which proves $H; T_{spar} \specStep H; T_{spar}'$ and $\erase{H}; \erase{T_{spar}} \parStep \erase{H}; \erase{T_{spar}'}$

From $H^\ddagger; \Theta_{i''}[(i', N'), S_2, N_{erase}] \; | \; T^\dagger \specStep^* H; \Theta_i[S_1 : (i', N')_r^x, S_2, N] \; | \; T$, we have $WF(T_{spar}')$

%Pop Write
\item $\infer[\text{PopWrite}]{H; \Theta_i[S_1: (i', N')_w^x, S_2, N] \; | \; T \rightarrow H'; \Theta_{i+1}[S_1, (i', N')_w^x : S_2, N] \; | \; T)}{H(x) = \langle ds, S, \Theta_i', M\rangle_x^c, \;\;\; H' = H[x \mapsto \langle ds, \cdot, \Theta_i', M\rangle_x^c]}$

Analogous to the PopRead case

%Pop new Full
\item $\infer[\text{PopNewFull}]{H; \Theta_i[S_1 : (i', N')_c^x, S_2, N] \; | \; T \rightarrow H';  \Theta_{i+1}[S_1, (i', N')_c^x : S_2, N] \; | \; T}{H(x) = \langle ds, S:A, \Theta_j', M \rangle_x^s, \;\;\; H' = H[x \mapsto \langle ds, S:A, \Theta_j', M\rangle_x^c]}$

Analogous to the PopRead case

\item $\infer[\text{PopNewEmpty}]{H; \Theta_i[S_1 : (i', N')_c^x, S_2, N] \; | \; T \rightarrow H';  \Theta_{i+1}[S_1, (i', N')_c^x : S_2, N] \; | \; T}{H(x) = \langle \rangle_x^s, \;\;\; H' = H[x \mapsto \langle \rangle_x^c]}$

Analogous to the PopRead case

%Pop Fork
\item $\infer[\text{PopFork}]{H; \Theta_i[S_1 : (i', M')_f^{\Theta_j'}, S_2, M] \; | \; \Theta_{j'}'[S_1' : spec, S_2', N] \; | \; T \rightarrow H; \Theta_{i+1}[S_1, (i', M')_f^{\Theta_j'} : S_2, M] \; | \; \Theta_{j' + 1}'[S_1', spec : S_2', N] \; | \; T}{}$

Analogous to the PopRead case

%PopSpec
\item $\inference[\text{PopSpec}]{}{\begin{array}{l} H; T \; | \; \Theta_i[\cdot, S_2, \eval{specReturn(return \; N_1, M_0, wait \; \Theta_1')}] \; | \; \Theta_j'[S_1' : (1, M)_s, S_2, return \; N_2]) \rightarrow \\ H; T \; | \; \Theta_{i+1}[\cdot, S_2, \eval{specReturn(return \; N_1, M_0, wait \; \Theta_1')}] \; | \; \Theta_{j+1}'[join : S_1', (1, M)_s : S_2', return \; N_1]) \end{array}}$


From $WF(H; T_{spar})$, we have $\unSpec{H}; \unSpec{T} \; | \; \Theta_i[\cdot, S_2, \eval{specReturn(return \; N_1, M_0, wait \; \Theta_1')}] \; | \; \Theta_1'[(1, M)_s, S_2, M] \specStep^* $

$H; T \; | \; \Theta_i[\cdot, S_2, \eval{specReturn(return \; N_1, M_0, wait \; \Theta_1')}] \; | \; \Theta_j'[S_1' : (1, M)_s, S_2, return\; N_2]$, but we can also construct the derivation for: $\unSpec{H}; \unSpec{T} \; | \; \Theta_i[\cdot, S_2, \eval{specReturn(return \; N_1, M_0, wait \; \Theta_1')}] \; | \; \Theta_1'[(1, M)_s, S_2, M] \specStep $

$\unSpec{H}; \unSpec{T} \; | \; \Theta_i[\cdot, (1, M)_s : S_2, \eval{specReturn(return \; N_1, M_0, wait \; \Theta_1')}] \; | \; \Theta_1'[\cdot, (1, M)_s : S_2, M] \specStep^*$

$H; T \; | \; \Theta_i[\cdot, S_2, \eval{specReturn(return \; N_1, M_0, wait \; \Theta_1')}] \; | \; \Theta_j'[S_1',  (1, M)_s : S_2, return\; N_2]$

\begin{comment}%Begin Comment
Now, we must show $WF(T_{spar}')$.  Consider two cases:

\begin{itemize}
\item $S_1 = \cdot$, for this case, let $T_1 = \unSpec{T}, T_1' = T$,\\
$T_2 = \Theta_i[\cdot, S_2, \eval{specReturn(return \; N_1, wait \; \Theta_1')}] \; | \; \Theta_1'[\cdot : (1, M)_s, S_2', M]$, and \\
$T_2' = \Theta_{i+1}[\cdot, S_2, \eval{specReturn(return \; N_1, wait \; \Theta_1')}] \; | \; \Theta_{j+1}'[\cdot, (1, M)_s : S_2', M']$

Since $\specActions{T_2} = \specActions{T_2'}$, we can apply Lemma \ref{independence} to get $v\vec{i}.(T_1 \; | T_2) \specStep^* v\vec{i}.(T_1 \; | \; T_2') \specStep^* v\vec{i}.(T_1' \; | \; T_2')$.

Since $\unSpec{T_{spar}'} = v\vec{i}.(T_1 \; | \; T_2')$ and $T_{spar}' = v\vec{i}.(T_1' \; | \; T_2')$, we have $WF(T_{spar}')$ 

\item $S_1 = S_1' : (i', M^*)_x^y$, for this case, let $T_1 = \unSpec{T}, T_1' = T$,\\
$T_2 = \Theta_i[\cdot, S_2, \eval{specReturn(return \; N_1, wait \; \Theta_1')}] \; | \; \Theta_1'[S_1' : (j', M^*)_x^y : (1, M)_s, S_2', M]$, \\
$T_2' = \Theta_{i+1}[\cdot, S_2, \eval{specReturn(return \; N_1, wait \; \Theta_1')}] \; | \; \Theta_{j'}'[S_1' : (j', M^*)_x^y, (1, M)_s : S_2', M^*]$, and  \\
$T_2'' = \Theta_{i+1}[\cdot, S_2, \eval{specReturn(return \; N_1, wait \; \Theta_1')}] \; | \; \Theta_{j+1}'[S_1' : (j', M^*)_x^y, (1, M)_s : S_2', M']$.  

From $WF(T_{spar})$, we have $\exists T_1^+, \vec{i}.(T_1 \; | \; T_2) \specStep^* v\vec{i}.(T_1^+ \; | \; T_2') \specStep^* v\vec{i}.(T_1' \; | \; T_2'')$

Since $\specActions{T_2} = \specActions{T_2'}$, by Lemma \ref{independence}, we have: 
$v\vec{i}.(T_1 \; | \; T_2) \specStep^* v\vec{i}.(T_1 \; | \; T_2') \specStep^* v\vec{i}.(T_1^+ \; | \; T_2') \specStep^* v\vec{i}.(T_1' \; | \; T_2'')$.  Since $\unSpec{T_{spar}} = v\vec{i}.(T_1 \; | \; T_2')$ and $T_{spar}' = v\vec{i}.(T_1' \; | \; T_2'')$, we have $WF(T_{spar}')$.  
\end{itemize}
\end{comment} %End Comment

%SpecRB
\item $\infer[\text{SpecRB}]{H; T \; | \; \Theta_i[\cdot, S_2, \eval{specReturn(raise \; M, wait \; \Theta_j')}] \; | \; \Theta_j'[S_1', S_2', M] \rightarrow H'; T' \; | \;  \Theta_{i+1}[\cdot, S_2, \eval{raise \; M}])}{rollback(\Theta_i, H, T \; | \; \Theta_j'[S_1', S_2', M]) \leadsto (H', \Theta_{j'}'[\cdot : (j'', M''), S_2'', M'] \; | \; T')}$

From $\erase{H; T_{spar}} = \erase{H}; \erase{T} \; | \; \eval{raise \; M >>= \backslash i. M \backslash j. return(i, j)}$, we can use the Raise rule to construct the derivation for:
$\erase{H}; \erase{T} \; | \; \eval{raise \; M >>= \backslash i. M >>= \backslash j. return(i, j)}) \parStep \erase{H}; \erase{T} \; | \; \eval{raise \; M})$ In order to show that $\erase{H'; T' \; | \; \Theta_{i+1}[S_1, S_2, \eval{raise \; M}]} = \erase{H}; \erase{T} \; | \; \eval{raise \; M}$, we must show that $\erase{H'; T'} = \erase{H; T}$, which follows immediately from Lemma \ref{eraseRollbackIdempotence}.  From Applying Lemma \ref{wfFrame} to $WF(T_{spar})$ we have $WF(H; \Theta_j'[S_1', S_2'])$.  Applying Lemma \ref{wellFormedRollback} to $WF(H; T \; | \; \Theta_j'[S_1', S_2', M])$ and $rollback(\Theta_i, H, \Theta_j'[S_1', S_2', M] \; | \; T) \leadsto (H', \Theta_{j'}'[(j'', M''), S_2'', M'] \; | \; T')$, we get $WF(H'; \Theta_{j'}'[(j'', M''), S_2'', M'] \;|\; T')$, 

which implies $\unSpec{H'}; \Theta_{j''}'[(j'', M''), S_2'', M''] \; \; | \; \unSpec{T'} \specStep^* H'; \Theta_{j'}'[(j'', M''), S_2'', M']$.  Applying Lemma \ref{independence} to this derivation we get 

$\unSpec{H'}; \Theta_{j''}'[(j'', M''), S_2'', M''] \; | \; \unSpec{T'} \specStep^* H'; \Theta_{j''}'[(j'', M''), S_2'', M''] \; | \; T' \specStep^* H'; \Theta_{j'}'[(j'', M''), S_2'', M'] \; | \; T'$

By applying Lemma \ref{frame} to  $\unSpec{H'}; \Theta_{j''}'[(j'', M''), S_2'', M''] \; | \; \unSpec{T'} \specStep^* H'; \Theta_{j''}'[(j'', M''), S_2'', M''] \; | \; T'$, we have $\unSpec{H'}; \unSpec{T'} \specStep^* H'; T'$, which implies $WF(H'; T')$.  Applying Lemma \ref{wfFrame} to $WF(H'; T')$ and $\Theta_{i+1}[\cdot, S_2 \; \eval{raise \; M}]$ we get $WF(H'; T' \; | \; \Theta_{i+1}[\cdot, S_2, \eval{raise \; M}])$

\end{itemize}
\end{proof}
\vspace{-2em}
%Well formed rollback
\begin{lemma}[Well-Formed Rollback]
\label{wellFormedRollback}
For all $\Theta_i, H, T$, if $rollback(\Theta_i, H, T) \leadsto T'$, and $WF(H; T)$, then $WF(H'; T')$. 
\end{lemma}

%Proof of rollback well formedness 
\begin{proof}
By structural induction on the derivation of $rollback(\Theta_i, H, T) \leadsto T'$:

\begin{itemize}
%Rollback Done Case
\item $rollback(\Theta_i, H, T) \leadsto (H',T') \equiv \infer[]{rollback(\Theta_i, H, \Theta_{i'}[\cdot : (i'', M')_s, M] \; | \; T) \leadsto (H, \Theta_{i'}[\cdot : (i'', M')_s, M] \; | \; T)}{}$
$WF(\Theta_{i'}[\cdot : (i'', M')_s, M] \; | \; T)$ is immediate from the assumptions. 

%Rollback Read Case
\item $rollback(\Theta_i, H, T ) \leadsto (H', T') \equiv$

$ \infer[]{rollback(\Theta_i, H, \Theta_j'[(j', M')_r^x : S_1, S_2, M] \; | \; T) \leadsto (H'', T')}{H(x) = \langle  \Theta_{j'}' \uplus ds, s, t, M\rangle, \;\;\; H' = H[x \mapsto \langle  ds, s, t, M\rangle] \;\;\; rollback(\Theta_i, H', \Theta_{j'}'[S_1, S_2, M'] \; | \; T) \leadsto (H'', T')}$

From $WF(H; \Theta_j'[(j', M')_r^x : S_1, S_2, M] \; | \; T)$, we have 

$\unSpec{H; \Theta_j'[ (j', M')_r^x : S_1, S_2, M] \; | \; T} \specStep^* H^*; \Theta_{j'}'[S_1, S_2, M'] \; | \; T^* \specStep H^*; \Theta_{j''}'[ (j', M')_r^x : S_1, S_2, M''] \; | \; T^* \specStep^* H; \Theta_j'[(j', M')_r^x : S_1, S_2, M] \; | \; T$.  

Applying Lemma \ref{independence} to $(j', M')_r^x : S_1 = (j', M')_r^x : S_1, S_2 = S_2$, and 

$H^*; T^* \; | \; \Theta_{j''}'[(j', M')_r^x : S_1, S_2, M'']  \specStep^* H; T \; | \; \Theta_j'[(j', M')_r^x : S_1, S_2, M] $, we get

$H^*; T^* \; | \; \Theta_{j''}'[(j', M')_r^x : S_1, S_2, M'']  \specStep^* H; T \; | \; \Theta_{j''}[ (j', M')_r^x : S_1, S_2, M''] \specStep^*H; T \; | \; \Theta_j'[(j', M')_r^x : S_1, S_2, M]$

Applying Lemma \ref{readIndependence} to $H(x) = \langle \Theta_j' \uplus ds, s, t, N\rangle_x^c$ and 

$H^*; \Theta_{j'}'[S_1, S_2, M'] \; | \; T^* \specStep H^*; \Theta_{j''}'[(j', M')_r^x : S_1, S_2, M''] \; | \; T^* \specStep^*  H; T \; | \; \Theta_{j''}[ (j', M')_r^x : S_1, S_2, M'']$, we get: $H^*; \Theta_{j'}'[S_1, S_2, M'] \; | \; T^* \specStep^* H[x\mapsto \langle ds, s, t, N\rangle_x^c]; \Theta_{j'}'[S_1, S_2, M'] \; | \; T $, finally yielding:

$\unSpec{H; \Theta_j'[(j', M')_r^x : S_1, S_2, M] \; | \; T} \specStep^* H^*; \Theta_{j'}'[S_1, S_2, M'] \; | \; T^* \specStep^* H[x\mapsto \langle ds, s, t, N\rangle_x^c]; \Theta_{j'}'[S_1, S_2, M'] \; | \; T$, which allows us to apply the induction hypothesis, and proves $WF(H''; T')$.


%Rollback Fork
\item $rollback(\Theta_i, H, T ) \leadsto (H', T') \equiv \infer[\text{RBFork}]{rollback(\Theta_i, H, \Theta_j'[(j', M')_f^{\Theta_k''} : S_1, S_2, M] \; | \; \Theta_{k'}''[spec, \cdot, N'] \; | \; T) \leadsto (H', T')}{rollback(\Theta_i, H, \Theta_{j'}'[S_1, S_2, M'] \; | \; T) \leadsto (H', T')}$

From $WF(H; \Theta_j'[(j', M')_f^{\Theta_k''} : S_1, S_2, M] \; | \; \Theta_{k'}''[spec, \cdot, N'] \; | \; T)$, we have:

$\unSpec{H; \Theta_j'[(j', M')_f^{\Theta_k''} : S_1, S_2, M] \; |\; T} \specStep^* H^*; \Theta_{j'}'[S_1, S_2, M'] \; | \; T^* \specStep H^*; \Theta_{j''}[(j', M')_f^{\Theta_k''} : S_1, S_2, M''] \; | \; \Theta_k''[spec, \cdot, N] \; | \; T^*  \specStep^* H; \Theta_j'[(j', M')_f^{\Theta_k''} : S_1, S_2, M] \; | \; \Theta_{k'}''[spec, \cdot, N'] \; | \; T$.

Applying Lemma \ref{independence} to 

$H^*;\Theta_{j''}[(j', M')_f^{\Theta_k''} : S_1, M''] \; | \; \Theta_k''[\cdot : spec, \cdot, N] \; | \;T^*  \specStep^* H; \Theta_j'[(j', M')_f^{\Theta_k''} : S_1, S_2, M] \; | \; \Theta_{k'}''[\cdot : spec, \cdot, N'] \; | \; T$

we get:

$H^*; \Theta_{j''}[(j', M')_f^{\Theta_k''} : S_1, M''] \; | \; \Theta_k''[\cdot : spec, \cdot, N] \; | \; T^*  \specStep^* H; \Theta_{j''}[(j', M')_f^{\Theta_k''} : S_1, M''] \; | \; \Theta_k''[\cdot : spec, \cdot, N] \; | \; T$.  Applying Lemma \ref{forkIndependence} to:

$H^*; \Theta_{j'}'[S_1, S_2, M'] \; | \; T^* \specStep H^*; \Theta_{j''}'[(j', M')_f^{\Theta_k''} : S_1, S_2, M''] \; | \; \Theta_k''[\cdot : spec, \cdot, N] \; | \; T^* \specStep^* H;  \Theta_{j''}'[(j', M')_f^{\Theta_k''} : S_1, S_2, M''] \; | \; \Theta_k''[\cdot : spec, \cdot, N] \; | \; T$, gives us:

$H^*; \Theta_{j'}'[S_1, S_2, M'] \; | \; T^* \specStep^* H; \Theta_{j'}'[S_1, S_2, M'] \; | \; T$, finally yielding: 

$\unSpec{H; \Theta_j'[\cdot : S_1, S_2, M] \; | \; T} \specStep^* H; T \; | \; \Theta_j'[S_1, S_2, M] \; | \; T$, which implies $WF(H; \Theta_{j'}'[S_1, S_2, M'] \; | \; T)$.  From here, we can apply the induction hypothesis, which gives us $WF(H'; T')$

%Rollback Write
\item $rollback(\Theta_i, H, T) \leadsto (H', T') \equiv $

$\infer[\text{RBWrite}]{rollback(\Theta_i, H, \Theta_j'[\cdot : (j', M')_w^x : S_1, S_2, M] \; | \; T) \leadsto (H'', T')}{H(x) = \langle [], s, t, N\rangle_x^c, \;\;\; H' = H[x \mapsto \langle\rangle_x^c] \;\;\; rollback(\Theta_i, H', \Theta_{j'}'[\cdot : S_1, S_2, M'] \; | \; T) \leadsto (H'', T')}$

From $WF(\Theta_j'[(j', M')_w^x : S_1, S_2, M] \; | \; T)$, we have:

$\unSpec{H; \Theta_j'[(j', M')_w^x : S_1, S_2, M] \; | \; T} \specStep^* H^*; \Theta_{j'}'[S_1, S_2, M'] \; | \; T^* \specStep H^*[x \mapsto \langle \emptyset, S_1, \Theta_{j'}, N\rangle_x^{sc}]; \Theta_{j''}'[(j', M')_w^x : S_1, S_2, M''] \; | \; T^* \specStep^* H; \Theta_j'[(j', M') : S_1, S_2, M] \; | \; T$.  Applying Lemma \ref{independence} to:

$H^*[x \mapsto \langle \emptyset, S_1, \Theta_{j'}, N\rangle_x^{sc}]; \Theta_{j''}'[(j', M')_w^x : S_1, S_2, M''] \; | \; T^* \specStep^* H; \Theta_j'[(j', M')_w^x : S_1, S_2, M] \; | \; T$, we get:

$H^*[x \mapsto \langle \emptyset, S_1, \Theta_{j'}, N\rangle_x^{sc}]; \Theta_{j''}'[(j', M')_w^x : S_1, S_2, M''] \; | \; T^* \specStep^* H; \Theta_{j''}'[(j', M')_w^x : S_1, S_2, M''] \; | \; T$.  Applying Lemma \ref{writeIndependence} to $H(x) = \langle \emptyset, s, t, N\rangle_x^{sc}$ and $H^*; \Theta_{j'}'[S_1, S_2, M'] \; | \; T^* \specStep H^*[x \mapsto \langle \emptyset, S_1, \Theta_{j'}, N\rangle_x^{sc}]; \Theta_{j''}'[(j', M')_w^x : S_1, S_2, M''] \; | \; T^* \specStep^* H; \Theta_{j''}'[(j', M')_w^x : S_1, S_2, M''] \; | \; T$, we get:

$H^*; \Theta_{j'}'[S_1, S_2, M'] \; | \; T^* \specStep^* H[x \mapsto \langle\rangle_x^{sc}]; \Theta_{j'}'[S_1, S_2, M'] \; | \; T$, finally yielding:

$\unSpec{H; \Theta_j'[S_1, S_2, M] \; | \; T} \specStep^* H^*; \Theta_{j'}'[S_1, S_2, M'] \; | \; T^* \specStep^* H[x\mapsto \langle\rangle_x^{sc}]; \Theta_{j'}'[S_1, S_2, M'] \; | \; T$, which implies $WF(H[x \mapsto \langle\rangle_x^{sc}]; \Theta_{j'}'[S_1, S_2, M'] \; | \; T)$, allowing to apply the induction hypothesis, proving $WF(H''; T')$

%Rollback New
\item $rollback(\Theta_i, H, T) \leadsto (H', T') \equiv \infer[\text{RBNew}]{rollback(\Theta_i, H, \Theta_j'[(j', M')_c^x : S_1, S_2, M] \; | \; T) \leadsto (H'', T')}{H(x) = \langle\rangle_x, \;\;\; H' = H \backslash x \;\;\; rollback(\Theta_i, H', \Theta_{j'}'[S_1, S_2, M'] \; | \; T) \leadsto (H'', T')}$

This case is the same as the previous, except this it makes use of Lemma \ref{newIndependence} instead of Lemma \ref{writeIndependence}

%Rollback Spec 
\item $rollback(\Theta_i, H, T) \leadsto (H', T') \equiv$ \\
$ \infer[\text{RBSpec}]{rollback(\Theta_i, H, \Theta_j'[(j', M')_f^{\Theta_{k'}''} : S_1, S_2, M] \; | \; \Theta_k''[(k', N')_s : spec, \cdot, N] \; | \; T) \leadsto (H'', T'')}{rollback(\Theta_i, H, \Theta_j'[S_1, S_2, M] \; | \; T) \leadsto (H'', T'')}$

This case is analogous to third case.

\end{itemize}

\end{proof}

%Fork Independence Lemma
\begin{lemma}[Fork Independence]
\label{forkIndependence}
For all $H, H', T', T, \Theta_i$, if \\
$H; T \; | \; \Theta_i[S_1, S_2, M] \specStep H; T \; | \; \Theta_{i+1}[(i, M)_f^{\Theta_j'} : S_1, S_2, M'] \; | \; \Theta_j'[S_1', S_2', N] \specStep^* H'; T' \; | \; \Theta_{i+1}[(i, M)_f^{\Theta_j'} : S_1, S_2, M'] \; | \; \Theta_j'[S_1', S_2', N]$, then $H; T \; | \; \Theta_i[S_1, S_2, M] \specStep^* H'; T' \; | \; \Theta_i[S_1, S_2, M]$

\end{lemma}

%Proof of Fork Independence
\begin{proof}
Proven in Coq
\end{proof}

%Read Independence Lemma
\begin{lemma}[Read Independence]
\label{readIndependence}
For all $H, H', H'', T', T, \Theta_i, x$, if $H''(x) = \langle \Theta_{i'} \uplus ds, s, t, N\rangle_x^c$ and 

$H; T \; | \; \Theta_i[S_1, S_2, M] \specStep H'; T \; | \; \Theta_{i+1}[S_1 : (i, M)_r^x, S_2, M'] \specStep^* H''; T' \; | \; \Theta_{i+1}[S_1 : (i, M)_r^x, S_2, M']$, then 

$H; T \; | \; \Theta_i[S_1, S_2, M] \specStep^* H''[x\mapsto \langle ds, s, t, N\rangle_x^c]; T' \; | \; \Theta_i[S_1, S_2, M]$
\end{lemma}

%Proof of Read Independence Lemma
\begin{proof}
Analogous to Lemma \ref{forkIndependence}
\end{proof}



%Write no Read Independence Lemma
\begin{lemma}[Write Independence]
\label{writeIndependence}
For all $H, H', T, T', x, \Theta_i$, if $H'(x) = \langle \emptyset, s, t, N\rangle_x^{sc}$ and \\
$H;\Theta_i[S_1, S_2, M] \; | \; T \specStep H[x\mapsto \langle \emptyset, S_1, \Theta_i, N\rangle_x^{sc}]; \Theta_{i'}[(i, M)_w^x : S_1, S_2, M'] \; | \; T \specStep^* H'; \Theta_{i'}[(i, M)_w^x : S_1, S_2, M'] \; | \; T'$, then $H;\Theta_i[S_1, S_2, M] \; | \; T  \specStep^* H'[x\mapsto \langle\rangle_x^{sc}]; \Theta_{i'}[S_1, S_2, M'] \; | \; T'$
\end{lemma}

%Proof of Write no Read Independence Lemma
\begin{proof}
Analogous to Lemma \ref{forkIndependence}
\end{proof}

%Create Ivar independence
\begin{lemma}[New Independence]
\label{newIndependence}
For all $H, H', T, T', x, \Theta_i$, if $H'(x) = \langle\rangle_x^c$ and \\
$H; \Theta_i[S_1, S_2, M] \; | \; T \specStep H[x \mapsto \langle\rangle_x^s]; \Theta_{i'}[(i, M)_c^x : S_1, S_2, M'] \; | \; T \specStep^* H'; \Theta_{i'}[(i, M)_c^x : S_1, S_2, M'] \; | \; T'$, then\\
$H; \Theta_i[S_1, S_2, M] \; | \; T \specStep^* (H' \backslash x); \Theta_i[S_1, S_2, M] \; | \; T'$
\end{lemma}

\begin{proof}
Analogous to Lemma \ref{forkIndependence}
\end{proof}

%Rollback Erasure Idempotence
\begin{lemma}[Erasure Rollback Idempotent]
\label{eraseRollbackIdempotence}
For all $H, H', T, T', \Theta_i$, if $rollback(\Theta_i, H, T) \leadsto (H', T')$, then $\erase{H; T} = \erase{H'; T'}$

\end{lemma}

%Proof of Rollback Erasure Idempotence
\begin{proof}
Proven in Coq
\end{proof}

%NonspecPureStep
\begin{lemma}[NonSpecPureStep]
\label{nonSpecPureStep}
For all $H, H', T, T', \Theta_i$, If $H; \Theta_i[S_1, S_2, M] \; | \; T \specStep^* H'; \Theta_{i'}[S_1, S_2, M']\; | \; T'$, then $\erase{H}; \erase{M} \; | \; \erase{T} \parStep^* \erase{H'}; \erase{M'} \; | \; \erase{T'}$
\end{lemma}

\begin{proof}
Proven in Coq
\end{proof}

%Independence Lemma
\begin{lemma}[Independence]
\label{independence}
For all $H, T_1, T_2$, if $H; T_1 \; | \; T_2 \specStep^n H'; T_1' \; | \; T_2', \specActions{T_2} = \specActions{T_2}'$,  and $\commitActions{T_2} = \commitActions{T_2'}$, then: $H; T_1 \; | \; T_2 \specStep^{n_1} H^*; T_1' \; | \; T_2 \specStep^{n_2} H'; T_1' \; | \; T_2'$
\end{lemma}

%Proof of independence lemma
\begin{proof}
Proven in Coq
\end{proof}

%Nonspec Pure Single Step
\begin{lemma}[NonSpecPureSingleStep]
\label{nonSpecPureSingleStep}
For all $H, H', T, T', \Theta_i$, If $H; \Theta_i[S_1, S_2, M] \; | \; T \specStep H'; \Theta_{i'}[S_1, S_2, M']\; | \; T'$, then $\erase{H}; \erase{M} \; | \; \erase{T} \parStep \erase{H'}; \erase{M'} \; | \; \erase{T'}$
\end{lemma}

\begin{proof}
Proven in Coq
\end{proof}

%Reorder lemma
\begin{lemma}[Reorder]
\label{reorderLemma}
For all $H, T_1, T_2$, if $H; T_1 \; | \; T_2 \specStep H; T_1 \; | \; T_2' \specStep^n H'; T_1' \; | \; T_2', \specActions{T_2} = \specActions{T_2'}$, and $\commitActions{T_2} = \commitActions{T_2'}$, then $H; T_1 \; | \; T_2 \specStep^n H'; T_1' \; | \; T_2 \specStep H'; T_1' \; | \; T_2'$

\end{lemma}

%Proof of reorder lemma
\begin{proof}
Proven in Coq
\end{proof}

\begin{lemma}[Frame]
\label{frame}
For all $H, H', T_1, T_2, T_1', H; T_1 \; | \; T_2 \specStep^* H'; T_1' \; | \; T_2 \leftrightarrow H; T_1 \specStep^* H'; T_1'$
\end{lemma}

\begin{proof}
Proven in Coq
\end{proof}

\begin{lemma}
\label{wfFrame}
For all $H, T_1, T_2$ if $\specActions{T_2} = \emptyset$, then $WF(H; T_1 \; | \; T_2) \leftrightarrow WF(H; T_1)$
\end{lemma}

\begin{proof}
Proven in Coq
\end{proof}

\begin{lemma}
\label{wfIntermediate}
For all $H, H', T, T'$, If $WF(H; T)$ and $\unSpec{H}; \unSpec{T} \specStep^* H'; T' \specStep^* H; T$, then $\unSpec{H} = \unSpec{H'}$ and $\unSpec{T} = \unSpec{T'}$
\end{lemma}

%Idempotence of un-speculate and erasure
\begin{lemma}[Unspeculate-Erasure Idempotence]
\label{usEraseIdem}
For all $T, \erase{\unSpec{T}} = \erase{T}$

\end{lemma}

\begin{proof}
Proven in Coq
\end{proof}

\begin{displaymath}
\begin{array}{rcll}
\unSpec{H; T} &=& \unSpec{H}; \unSpec{T} \\
\unSpec{T_1 \; | \; T_2} &=& \unSpec{T_1} \; | \; \unSpec{T_2} \\
\unSpec{\Theta_i[S_1 : (i', M')_r^x, S_2, M]} &=& \Theta_{i'}[\cdot, S_2,M'] \\
\unSpec{\Theta_i[S_1 : (i', M')_w^x, S_2,M]} &=& \Theta_{i'}[\cdot, S_2,M'] \\
\unSpec{\Theta_i[S_1 : (i', M')_c^x, S_2,M]} &=& \Theta_{i'}[\cdot, S_2,M'] \\
\unSpec{\Theta_i[S_1 : (i', M')_f^x, S_2,M]} &=& \Theta_{i'}[\cdot, S_2,M'] \\
\unSpec{\Theta_i[S_1 : (i', M')_s, S_2,M]} &=& \Theta_{i'}[\cdot : (i', M')_s, S_2,M'] \\
\unSpec{\Theta_i[S_1 : spec, S_2,M]} &=& \cdot \\
\unSpec{\Theta_i[\cdot : join, S_2, M]} &=& \Theta_i[\cdot : join, S_2, M]\\
\unSpec{\Theta_i[\cdot, S_2, M]} &=& \Theta_i[\cdot, S_2, M]\\
\unSpec{H, x \mapsto \langle\rangle_x^s} &=& \unSpec{H} \\
\unSpec{H, x \mapsto \langle ds, s, tid, M\rangle_x^s} &=& \unSpec{H} \\
\unSpec{H, x \mapsto \langle\rangle_x^c} &=& \unSpec{H}, x\mapsto \langle\rangle_x^c \\
\unSpec{H, x\mapsto \langle ds, S : A, tid, M\rangle_x^c} &=& \unSpec{H}, x \mapsto \langle\rangle_x^c \\
\unSpec{H, x \mapsto \langle ds, \cdot, tid, M\rangle_x^c} &=& \unSpec{H}, x \mapsto \langle [], \cdot, tid, M\rangle_x^c \\
\end{array}
\end{displaymath}

\[
\infer[\text{WellFormed}]{WF(H; T)}{\unSpec{H; T} \specStep^* H; T}
\]

\end{document}




Well formed thread pool-----
For each step, show that a thread can always step from its spec recorded computation to where it is now.








