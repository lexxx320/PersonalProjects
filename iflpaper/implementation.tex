%!TEX root = paper.tex
\section{Implementation}
In addition to the formal semantics and determinism proof we have also begun a preliminary implementation as a part of the Manticore project.  We have implemented the rollback mechanism and an IVar library using the BOM intermediate language that is used for much of the rest of the runtime system and thread scheduling infrastructure \cite{sched-framework-for-parallel}. One key feature that the BOM intermediate language has is first class continuations, which allow us to ``reset'' threads to previous points in their evaluation.

\subsection{Threads in Manticore}
In Manticore, threads are simply represented as a unit continuation and a pointer to thread local storage.  We store the action list described in the formal semantics inside of thread local storage.  When a thread is created, we can provide a cancelable object such that each time the thread is scheduled, it first checks to see if a flag in the cancelable object has been set and if so, it terminates.  More details about about cancelation and thread scheduling can be found in \cite{implicit-threading-in-manticore:jfp}.


\subsection{IVars}
An IVar is represented as a record almost identically as it is in the formal semantics.  The main difference is in the list of dependent readers of an IVar.  In the formal semantics, this is simply a multi set of thread IDs, however, in our implementation it is actually a tuple containing the cancelable object associated with the reader, a continuation corresponding to the current continuation of the reader at the point it is performing the read, and a pointer to the list of actions it has performed.  When a thread reads from an IVar, it captures its current continuation, and stores it in the IVar along with its cancelable object and action pointer.  In the event that a rollback is invoked, we recursively go through the list of actions to be rolled back doing the following for each action:

\begin{itemize}
\item If the action is a fork action, cancel the forked thread (cancelable object is stored in the action object) and append all of the forked thread's actions to the list of actions to be rolled back
\item If the action is a read action, we simply continue with the rollback
\item If the action is a write action, reset the IVar to empty, and process each of the dependent readers associated with this IVar.  
\begin{itemize}
\item When processing dependent readers, we recurse down the list of actions they have performed and look for the oldest read action to the IVar being rolled back.  Note that it must be the oldest action because if the thread read from the IVar multiple times, we need to reset it back to the point at which it read from the IVar for the first time.  
\item We then reset this thread to the continuation associated with this read action and append the actions occurring after the read to the list of action to be rolled back.
\end{itemize}

\end{itemize}

Note that we do not record an action for allocating an IVar.  This is done in the formal semantics for the purposes of maintaining the well-formedness property and is not necessary to rollback the creation of IVars as they will simply be garbage collected.  The reason this is important for preserving the well-formedness property is that after unspeculating a program state, it must be able to run forward to exactly the state it was in prior to unspeculating.  This means that the names chosen for IVars in the heap must be the same as the were previously, which would not be possible if speculatively allocated IVars where not removed from the heap.  






















































%%-------------------------------------------------------------------------OLD------------------------------------------------------------------------
\begin{comment}

Throughout this implementation we use a naming convention for uniquely assigning thread IDs to newly created threads.  A thread ID consists of a list of elements where each element consists of a major and minor number.  The main thread starts out with ID \mbox{[(1, 1)]}.  Each time a thread calls {\bf fork}, we increment its minor number by one.  When creating a newly forked thread, we extend its parent's ID with the pair (0, 1) and for each thread created in a parallel tuple, we extend their parent's thread ID with the pair ($i$, 1) where $i$ is the position of the thread in the tuple. For example, the thread IDs for the threads created in line 4 of Figure \ref{transitive} would be:

$$
\text{fork} \overbrace{((|\underbrace{\text{raise E}}_{[(1, 1), (0, 1), (1, 1)]}, \underbrace{\text{IVar.put}(i, 10)}_{[(2, 1), (0, 1), (1, 1)]}|)\text{ handle E }=> ((), ())}^{[(0, 1), (1, 1)]}
$$

Intuitively, the major number in a thread ID element corresponds to what kind of thread was spawned (i.e. a forked thread or a parallel tuple thread in position $i$). The minor number is used for uniqueness in the presence of {\bf fork}.  Consider the following example:

\begin{lstlisting}[mathescape]
val _ = fork (|$e_1$, $e_2$|)
val _ = fork (|$e_3$, $e_4$|)
\end{lstlisting}

If we only included the major numbers, we would end up assigning $e_1$ and $e_3$ the same thread IDs as well as $e_2$ and $e_4$.  

\subsection{Logging}

In order to enforce the sequential semantics, we must record some amount of information about threads at runtime.  First, we must distinguish between threads that could possibly be affected by a rollback and those that cannot.  We classify the former as ``speculative'' threads and the latter as ``commit'' threads.  The main thread starts off in commit mode.  If it reads from an IVar that was speculatively written, then it turns into a speculative thread.  A thread that was forked inherits its parent's speculative or commit state.  The thread in the first position of a parallel tuple also inherits its parent's speculative or commit state, while the remaining threads in the parallel tuple are all run speculatively.  Additionally, if a thread is running speculatively we must also record all IVars that it writes, reads, and threads that it spawns.  We log these ``actions'' to a list stored in thread local storage.  Lastly, if a thread reads a speculatively full IVar, we add this thread to a dependent reader list stored in the IVar itself.

\subsection{Rollback}
When an exception is raised inside of a parallel tuple, we cancel the rest of the speculatively running threads and pass their recorded actions to the runtime system to perform a rollback.  We process these action lists one element at a time in the order in which they occurred.  If the action at the head of the list is a read action, then we simply continue to the next action.  If it is a write, then we reset the IVar that was written to empty and process the threads that read from this IVar.  For each thread in the dependent reader list of this IVar, we take all their actions occurring after the read action of the IVar being rolled back, and append them to the action list currently being rolled back.  We then cancel the dependent reader thread, add them to a set of threads to be restarted, and continue with the rollback.  The last case is for a fork action.  In this case we simply cancel the thread and append all of its actions to the list of actions being rolled back.  

When we are finished processing the list of actions, we are left with a set of dependent readers who need to get restarted at the points before they read from their respective IVars.  However, we must be careful about restarting these threads so as to not end up with any duplicate threads.  As an example, consider Figure \ref{indSet}.  Here we fork a thread that in parallel raises an exception and writes to an IVar $i$.  Assuming that both the reads from lines 5 and 6 go through, we will have recorded both of these threads as dependent readers, however, when we reset the main thread back to line 5 it will perform the read and then fork the thread in line 6.  If we were to also reset the forked thread to before it performed its read we would end up with two copies of the same thread.  

\begin{figure}
\lstinputlisting[numbers=left, xleftmargin=5.0ex, morekeywords=fork]{programs/indSet.pml}
\caption{Minimal Independent Set}
\label{indSet}
\end{figure}

Fortunately, we can compute the ``minimal independent set'' of threads to restart based on their thread IDs.  We define a set of threads to be minimally independent if no thread ID is a prefix of another thread ID in the set, where prefix is recursively defined as follows:  

\begin{itemize}
\item The empty thread ID is a prefix of any thread ID
\item ID$_1$ is a prefix of ID$_2$ if:
\begin{itemize}
\item ID$_1 = [\text{ID}_1', (M_1, m_1)]$ and ID$_2 = [\text{ID}_2', (M_2, m_2)]$
\item $M_1 = M_2$
\item $m_1 \leq m_2$
\item ID$_1'$ is a prefix of ID$_2'$
\end{itemize}
\end{itemize}

Notice that this definition directly corresponds to ``ID$_1$ spawned ID$_2$ or ID$_1$ spawned a thread that spawned ID$_2$.''  Going back to the example in Figure \ref{indSet}, we can see that the ID of the thread performing the read in line 5 will be $[(0, 2)]$ and the ID of the thread that gets forked in line 6 will be $[(0, 1), (0, 2)]$.  We can see from the previous definition that $[(0, 2)]$ is a prefix of $[(0, 1), (0, 2)]$ because $0 = 0$, $2 \le 2$, and the empty thread ID is a prefix of $[(0, 1)]$, therefore we will choose not to restart the thread corresponding to $[(0, 1), (0, 2)]$.  More generally, with this definition in place, we can be sure that by restarting the minimal independent set of dependent readers we will not end up with any duplicate threads after performing a rollback.


\subsection{Committing} 
The last aspect to consider is transitioning threads from a speculative state to a  commit state.  When a thread is able to make the transition from speculative to commit, it processes its action list one element at a time in the order in which they occurred.  If the action at the head of their list is a read action, we can continue with the commit if the IVar that was read is now committed.  If it is not, then the commit blocks until the IVar switches to a commit state.  If the action at the head of the list is a write action, we mark the IVar as committed, unblock any threads that are waiting for this IVar to get committed, and continue.  Lastly, if the action at the head of the list is a fork action, then we update the forked thread's speculative state to commit. Threads that were created using fork are able to enter the commit process when their parent sets their speculative flag to commit.  Threads created in the first position of a parallel tuple may also enter the commit process when their parent sets their speculative flag, however, the remaining threads are not able to commit until the thread in the preceding position of the parallel tuple finishes and commits their actions.  Intuitively, the commit process follows the same execution path as if the program was running sequentially.  



\end{comment}















