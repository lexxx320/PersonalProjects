%!TEX root = paper.tex

\nopagebreak
\onecolumn

\begin{figure}
$\boxed{\finished(H; T)} $
\[
\mbox{\small
\inference[]{\finished(H; T_1) \; | \; \finished(H; T_2)} {\finished(H; T_1 \; | \; T_2)}\;
\inference[]{H(x) = \langle \commit \rangle} {\finished(H; \Theta[S_1, S_2, \eval{\getKW \; x}])}
}
\]

\[
\mbox{\small
\inference[]{}{\finished(H; \Theta[\cdot, S_2, \return \; M])} \;
\inference[]{}{\finished(H; \Theta[S:A, S_2, M])}
}
\]
\caption{Finished Thread Pool}
\label{fig:finished}
\end{figure}

\begin{figure}
\begin{displaymath}
\begin{array}{rcll}
adopt(S : (R, x, M), E, M') &=& adopt(S, E, N) : (R, x, \eval{\specJoinKW(N, M)}) \\
adopt(S : (W, x, M), E, M') &=& adopt(S, E, N) : (W, x, \eval{\specJoinKW(N, M)}) \\
adopt(S : (A, x, M), E, M') &=& adopt(S, E, N) : (A, x, \eval{\specJoinKW(N, M)}) \\
adopt(S : (F, \Theta, M), E, M') &=& adopt(S, E, N) : (F, \Theta, \eval{\specJoinKW(N, M)}) \\
adopt(S : (S, M), E, M') &=& adopt(S, E, N) : (S, \eval{\specJoinKW(N, M)}) \\
adopt(S : CSpec, E, M') &=& adopt(S, E, N) : CSpec\\
\end{array}
\end{displaymath}
\caption{Action Adoption}
\label{fig:adopt}
\end{figure}


\begin{figure}
\begin{displaymath}
\begin{array}{rcll}
x &\in& Var \\

\text{Values} \;\;\;\; V & ::= & x \; | \; i \; | \; \backslash x. M  \; | \; \return \; M \; | \; M >>= N \; | \; \runPar \; M \; | \; \fork \; M \; | \; \new \; | \; \putKW \; i \; M \\
& | & \getKW \; i \; | \;  \doneKW \; M \; | \; \specKW \; M \; N \; | \; \specRunKW(M, N) \; | \; \specJoinKW(M, N) \; | \; \raiseKW \; M \\
& | & \handleKW \; M \; N  \\

\text{Terms} \;\;\; M, N &::=&  V \;| \;M \; N \; | \; \cdots\\

\text{Heap} \;\;\; H &::=& H, x \mapsto iv \; | \; \cdot \\

\text{IVar State} \;\;\; iv &::=& \langle \rangle \; | \; \langle M\rangle \\

\text{Evaluation Context} \;\;\;\; E &::=& [\cdot] \; | \; E >>= M \; | \; \specRunKW(E, M) \; | \; \handleKW \; E \; N \; | \; \specJoinKW(N, E) \\

\text{Thread Pool} \;\;\;\; T &::=& \cdot \; | \; (T_1 \; | \; T_2) \; | \; M \\

\text{Configuration} \;\;\;\; \sigma &::=& H; T \; | \; Error \\
\end{array}
\end{displaymath}
\caption{Original Par Monad Syntax}
\label{fig:par-syntax}
\end{figure}

\begin{figure}
\[
\mbox{\small
\inference[\text{FPar}]{\pFinished(H; T_1) \;\;\;\; \pFinished(H; T_2)}{\pFinished(H; T_1 \; | \; T_2)} \;\;\;
\inference[\text{FBlocked}]{H(x) = \langle\rangle}{\pFinished(H; \eval{\getKW \; x})} \;\;\;
\inference[\text{FDone}]{}{\pFinished(H; \return \; M)}
}
\]

\caption{Original Par Monad Finished}
\label{fig:par-finished}

\end{figure}

\begin{figure}
\[
\inference[\text{RunPar}]{(M >>= \backslash x. \doneKW \; x) \parStep^* \doneKW \; N \; | \; T\;\;\; N \Downarrow V \;\;\; \pFinished(T)}{\runPar \; M \Downarrow V}
\]

\[
\inference[\text{Eval}]{M \Downarrow V}{H; T \; | \; \eval{M} \parStep H; T \; | \; \eval{V}} \;\;\;
\inference[\text{Bind}]{}{H; T \; | \; \eval{\return \; N >>= M} \parStep H; T \; | \; \eval{M \; N}}
\]

\[
\inference[\text{BindRaise}]{}{H; T \; | \; \eval{\raiseKW \; N >>= M} \parStep H; T \; | \; \eval{\raiseKW N}} \;\;\;
\inference[\text{Handle}]{}{H; T \; | \; \eval{\handleKW(\raiseKW \; M) N} \parStep H; T \; | \; \eval{M \; N}}
\]

\[
\inference[\text{HandleRet}]{}{H; T \; | \; \eval{\handleKW(\return \; M) N} \parStep H; T \; | \; \eval{\return \; M}} \;\;\;
\inference[\text{Fork}]{}{H; T \; | \; \eval{\fork \; M} \parStep H; \eval{\return ()} \; | \; M \; | \; T }
\]

\[
\inference[\text{New}]{x \notin Domain(H) \;\;\; H' = H[x\mapsto \langle\rangle]}{H; \eval{\new} \; | \; T \parStep H'; T \; | \; \eval{\return \; x}} \;\;\;
\inference[\text{Get}]{H(x) = \langle M \rangle}{H; \eval{\getKW \; x} \; | \; T \parStep H; \eval{\return \; M} \; | \; T}
\]

\[
\inference[\text{Put}]{H(x) = \langle\rangle \;\;\; H' = H[x\mapsto \langle M \rangle]}{H; \eval{\putKW \; x \; M} \; | \; T \parStep H'; \eval{\return ()} \; | \; T} \;\;\;
\inference[\text{Spec}]{}{H; \eval{\specKW \; M \; N} \; | \; T \parStep H; \eval{\specRunKW(M, N)} \; | \; T}
\]

\[
\inference[\text{SpecRun}]{}{H; \eval{\specRunKW(\return \; M, N)} \; | \; T \parStep H; \eval{\specJoinKW(\return \; M, N)} \; | \; T} 
\]

\[
\inference[\text{SpecRaise}]{}{H; \eval{\specRunKW(\raiseKW \; M, N)} \; | \; T \parStep H; \eval{\raiseKW \; M} \; | \; T}
\]

\[
\inference[\text{specJoin}]{}{H; \eval{\specJoinKW(\return \; M, \return \; N)} \; | \; T \parStep H; \eval{\return(M, N)} \; | \; T}
\]

\[
\inference[\text{specJoinRaise}]{}{H; \eval{\specJoinKW(\return \; M, \raiseKW \; N)} \; | \; T \parStep H; \eval{\raiseKW \; N} \; | \; T}
\]

\caption{Original Par Monad Operational Semantics}
\label{fig:par-semantics}
\end{figure}













