%!TEX root = paper.tex
\section{Preliminary Results}
Our implementation is still in its early stages, however, we have been able to perform some preliminary evaluation in order to give the reader a sense as to what sort of overhead is introduced by our logging and rollback mechanism in Manticore.  

\subsection{Producer Consumer}
The first benchmark is a simple program that spawns two threads, one that repeatedly writes some arbitrary data to a linked list of IVars and another that reads each element of the linked list as it becomes available.  This gives us some idea as to what sort of price we pay even if we have no interest in doing any sort of speculative computation.  For a program that writes 5,000 IVars we see only a 5\% slowdown relative to an implementation that performs no logging.  

\begin{figure}
\includegraphics[scale=.5]{SyntheticResults.pdf}
\caption{Rollback Overhead}
\label{synthetic}
\end{figure}

\subsection{Measuring Rollback}

In an effort to measure the overhead introduced by the rollback mechanism we have constructed a synthetic benchmark that forks a thread that speculatively writes to an IVar, and with a given probability raises an exception to rollback the write after a predetermined amount of time.  After forking this thread, the main thread then reads from the speculatively written IVar in order to record a dependent reader and then enters a spin loop for the same predetermined amount of time as the forked thread.  When a rollback occurs, the runtime system will then reset the written IVar to empty and reset the main thread to before the point that it read from the IVar.  If a rollback does not occur, then the two spin loops are executed in parallel and should, in theory, achieve 2X speedup.  Figure \ref{synthetic} shows the results of the experiment varying the probability of performing a rollback from 0 to 1 in 0.1 increments.  The execution times for each probability interval are the average of 500 iterations.  For the non speculative results, we simply run the two spin loops sequentially in order to get a baseline execution that does not involve the runtime system.  The results indicate that for this particular scenario, the overhead of a rollback is essentially free.  The average runtime of the non speculative case is 0.1833 seconds vs. 0.1834 for the average speculative runtimes with a 100\% chance of a rollback occurring.


Certainly these results will vary based on the ``size'' of the rollback, meaning if we had more threads dependently reading from the IVar, or we were speculatively writing to more IVars, the execution time would definitely be different as the runtime system would need to do more work.  Future work will include a more in-depth analysis of these parameters.
