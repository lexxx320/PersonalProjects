%!TEX root = paper.tex

\section{Introduction}

Writing parallel applications is a notoriously difficult task.  Programmers are forced to reason about the exponential interleaving of threads and nondeterministic behavior. One way of avoiding these difficulties is to use a functional language when developing parallel applications as they prohibit the alteration of shared state.  Race conditions and nondeterminism arise when multiple threads attempt to read and write to the same location in memory.  Since functional languages do not allow this, we avoid race conditions all together, making determinism simple to enforce.  Unfortunately, there are applications that can be more efficiently implemented when shared state can be used.  One attempt at addressing this problem is the use of IVars ~\cite{i-structures}, which are shared references that may only be written to once.  IVars have been proven to preserve determinism in an otherwise purely functional parallel language \cite{par-monad, cnc}, while allowing threads to communicate results to one another via shared memory.

In this work we show that in the presence of speculation -- a method for parallelizing programs, where unneeded tasks may be canceled -- the determinism guarantee for IVars no longer holds. Additionally this paper makes the following contributions:

\begin{itemize}
\item We propose a rollback mechanism that can be used to restore deterministic execution in the presence of speculation and IVars, and describe an implementation that is under development in the Manticore project.

\item We provide a formal semantics of a parallel language with speculative parallelism, IVars, and the proposed runtime system.

\item We give a mechanized proof, using the Coq Proof Assistant, that the runtime system is able to preserve determinism in the presence of these two features.

\end{itemize}

Source code for the Coq formalization can be found at: \url{http://people.rit.edu/ml9951/research.html}.

\section{Background}
\subsection{IVars}

IVars are shared memory references that may only be written to once, originally proposed as part of the parallel functional language Id \cite{i-structures}.  The interesting property about IVars is that they do not compromise the determinism guarantees that one can make about an otherwise purely functional parallel language.  Meanwhile, they strictly increase the expressiveness of the language.  As an example, consider an application implementing producer-consumer parallelism where two threads are running in parallel, one of which writes data into a shared buffer and the other processes this data as soon as it becomes available.  This sort of pattern cannot be efficiently implemented in a purely functional language.  In this case, the producer would be required to produce all of its elements before the consumer could start processing them.  On the other hand, if we are able to make use of IVars, we could implement the shared buffer as a linked list giving us the desired behavior.

Informally, the semantics of IVars are as follows.  When an IVar is created it starts off empty. When it is written to, it becomes full and if a thread attempts to write to it again, a runtime error is produced and the program terminates.  If a thread tries to read from an IVar that is empty, it blocks until the contents are filled, after which it can read from the IVar an arbitrary number of times without synchronization.  

\subsection{Speculative Parallelism}
Speculation is a method for parallelizing applications, where some number of parallel tasks are created and if it turns out that any of these tasks are unneeded, they are canceled.  This sort of pattern arises frequently in search problems where we want to search multiple paths in parallel, and then when a solution is found, we would like to cancel the rest of the search threads so as to free up resources for future computations.  For additional examples of speculatively parallel algorithms, see \cite{programmable-spec-par, burton-spec-par,spec-lexical-analysis}.

\subsection{Manticore}

Manticore is a compiler for a purely functional subset of Standard ML which has been extended with parallel features.  These parallel features are given a sequential semantics, allowing programmers to reason about parallel computations in the same way they would their sequential counterparts.  The most basic parallel construct in Manticore is the parallel tuple, denoted

\begin{centercode}
\cdmath{}(|$e_1$, $\ldots$, $e_n$|)
\end{centercode}%

Parallel tuples express fork-join parallelism, where each expression $e_i$ is evaluated in parallel.  The result of the entire expression is a data structure containing the results of each $e_i$.

Additionally, we provide a construct for asynchronously spawning threads via {\bf fork}.  The {\bf fork} construct takes an expression that gets evaluated in a separate thread allowing the main thread to continue with the execution of the remainder of the program.  

 In addition to parallelism, Manticore also supports exception handling.  The semantics for a regular sequential tuple are to evaluate each $e_i$ in left to right order, so if an exception gets raised, it will always be the leftmost exception in the tuple that gets propagated.  Enforcing the sequential semantics for parallel tuples in the presence of exceptions works as follows.  If expression $e_i$ raises an exception, then the threads evaluating expressions $e_{i+1}$ through $e_n$ are canceled and we wait for the previous $i-1$ elements to terminate to check if they raise an exception. 


\subsection{Determinism}
In Manticore we can encode this notion of speculative parallelism using the parallel constructs and exception handling features while maintaining the sequential semantics\cite{implicit-threading-in-manticore}.  Unfortunately, if we were to incorporate IVars into the language, we would lose this guarantee due to the cancelation associated with raised exceptions.  As an example, consider the code in Figure \ref{unsafe}.  In line 2 we create an empty IVar, and then in parallel raise an exception and write to this IVar.  There are two ways in which this can play out.  The cancelation can go through before the write, leaving the IVar empty, or the write can go through before the cancelation leaving the IVar full with the value 10.  These two scenarios lead to two different observable behaviors of our program, either it could block indefinitely due to a read from an empty IVar, or it could terminate with $x$ bound to the value 10.  In order to enjoy the benefits of a deterministic parallel language, we must extend the Manticore runtime system to avoid these race conditions.

\begin{figure}
\lstinputlisting[numbers=left, xleftmargin=5.0ex, morekeywords={fork}]{programs/unsafe.pml}
\caption{Nondeterministic Example}
\label{unsafe}
\end{figure}









